type Admin {
  id: ID!
  name: String!
  email: String!
  password: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type AdminConnection {
  pageInfo: PageInfo!
  edges: [AdminEdge]!
  aggregate: AggregateAdmin!
}

input AdminCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
}

type AdminEdge {
  node: Admin!
  cursor: String!
}

enum AdminOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AdminPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type AdminSubscriptionPayload {
  mutation: MutationType!
  node: Admin
  updatedFields: [String!]
  previousValues: AdminPreviousValues
}

input AdminSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AdminWhereInput
  AND: [AdminSubscriptionWhereInput!]
  OR: [AdminSubscriptionWhereInput!]
  NOT: [AdminSubscriptionWhereInput!]
}

input AdminUpdateInput {
  name: String
  email: String
  password: String
}

input AdminUpdateManyMutationInput {
  name: String
  email: String
  password: String
}

input AdminWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  NOT: [AdminWhereInput!]
}

input AdminWhereUniqueInput {
  id: ID
  email: String
}

type AggregateAdmin {
  count: Int!
}

type AggregateAnswer {
  count: Int!
}

type AggregateChangePasswordRequest {
  count: Int!
}

type AggregateCity {
  count: Int!
}

type AggregateCountry {
  count: Int!
}

type AggregateCurrency {
  count: Int!
}

type AggregateExpertise {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateForm {
  count: Int!
}

type AggregateFormResponse {
  count: Int!
}

type AggregateFormScore {
  count: Int!
}

type AggregateInvitation {
  count: Int!
}

type AggregateOrganization {
  count: Int!
}

type AggregateOrganizationStaff {
  count: Int!
}

type AggregatePaymentMethod {
  count: Int!
}

type AggregateQuestion {
  count: Int!
}

type AggregateScore {
  count: Int!
}

type AggregateScoringFormatSetting {
  count: Int!
}

type AggregateSector {
  count: Int!
}

type AggregateSystemSubscription {
  count: Int!
}

type AggregateSystemSubscriptionPlan {
  count: Int!
}

type AggregateTimezone {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateWorkflow {
  count: Int!
}

type AggregateWorkflowApplication {
  count: Int!
}

type AggregateWorkflowJudge {
  count: Int!
}

type AggregateWorkflowSubscription {
  count: Int!
}

type AggregateWorkflowSubscriptionPlan {
  count: Int!
}

type Answer {
  id: ID!
  value: String
  file: File
  email: String
  date: DateTime
  multipleSelection(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer!]
  question: Question!
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score!]
  type: QuestionType
  createdAt: DateTime
  updatedAt: DateTime
}

type AnswerConnection {
  pageInfo: PageInfo!
  edges: [AnswerEdge]!
  aggregate: AggregateAnswer!
}

input AnswerCreateInput {
  id: ID
  value: String
  file: FileCreateOneInput
  email: String
  date: DateTime
  multipleSelection: AnswerCreateManyInput
  question: QuestionCreateOneWithoutAnswersInput!
  scores: ScoreCreateManyWithoutAnswerInput
  type: QuestionType
}

input AnswerCreateManyInput {
  create: [AnswerCreateInput!]
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateManyWithoutQuestionInput {
  create: [AnswerCreateWithoutQuestionInput!]
  connect: [AnswerWhereUniqueInput!]
}

input AnswerCreateOneWithoutScoresInput {
  create: AnswerCreateWithoutScoresInput
  connect: AnswerWhereUniqueInput
}

input AnswerCreateWithoutQuestionInput {
  id: ID
  value: String
  file: FileCreateOneInput
  email: String
  date: DateTime
  multipleSelection: AnswerCreateManyInput
  scores: ScoreCreateManyWithoutAnswerInput
  type: QuestionType
}

input AnswerCreateWithoutScoresInput {
  id: ID
  value: String
  file: FileCreateOneInput
  email: String
  date: DateTime
  multipleSelection: AnswerCreateManyInput
  question: QuestionCreateOneWithoutAnswersInput!
  type: QuestionType
}

type AnswerEdge {
  node: Answer!
  cursor: String!
}

enum AnswerOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
  email_ASC
  email_DESC
  date_ASC
  date_DESC
  type_ASC
  type_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AnswerPreviousValues {
  id: ID!
  value: String
  email: String
  date: DateTime
  type: QuestionType
  createdAt: DateTime
  updatedAt: DateTime
}

input AnswerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  type: QuestionType
  type_not: QuestionType
  type_in: [QuestionType!]
  type_not_in: [QuestionType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AnswerScalarWhereInput!]
  OR: [AnswerScalarWhereInput!]
  NOT: [AnswerScalarWhereInput!]
}

type AnswerSubscriptionPayload {
  mutation: MutationType!
  node: Answer
  updatedFields: [String!]
  previousValues: AnswerPreviousValues
}

input AnswerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AnswerWhereInput
  AND: [AnswerSubscriptionWhereInput!]
  OR: [AnswerSubscriptionWhereInput!]
  NOT: [AnswerSubscriptionWhereInput!]
}

input AnswerUpdateDataInput {
  value: String
  file: FileUpdateOneInput
  email: String
  date: DateTime
  multipleSelection: AnswerUpdateManyInput
  question: QuestionUpdateOneRequiredWithoutAnswersInput
  scores: ScoreUpdateManyWithoutAnswerInput
  type: QuestionType
}

input AnswerUpdateInput {
  value: String
  file: FileUpdateOneInput
  email: String
  date: DateTime
  multipleSelection: AnswerUpdateManyInput
  question: QuestionUpdateOneRequiredWithoutAnswersInput
  scores: ScoreUpdateManyWithoutAnswerInput
  type: QuestionType
}

input AnswerUpdateManyDataInput {
  value: String
  email: String
  date: DateTime
  type: QuestionType
}

input AnswerUpdateManyInput {
  create: [AnswerCreateInput!]
  update: [AnswerUpdateWithWhereUniqueNestedInput!]
  upsert: [AnswerUpsertWithWhereUniqueNestedInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  deleteMany: [AnswerScalarWhereInput!]
  updateMany: [AnswerUpdateManyWithWhereNestedInput!]
}

input AnswerUpdateManyMutationInput {
  value: String
  email: String
  date: DateTime
  type: QuestionType
}

input AnswerUpdateManyWithoutQuestionInput {
  create: [AnswerCreateWithoutQuestionInput!]
  delete: [AnswerWhereUniqueInput!]
  connect: [AnswerWhereUniqueInput!]
  set: [AnswerWhereUniqueInput!]
  disconnect: [AnswerWhereUniqueInput!]
  update: [AnswerUpdateWithWhereUniqueWithoutQuestionInput!]
  upsert: [AnswerUpsertWithWhereUniqueWithoutQuestionInput!]
  deleteMany: [AnswerScalarWhereInput!]
  updateMany: [AnswerUpdateManyWithWhereNestedInput!]
}

input AnswerUpdateManyWithWhereNestedInput {
  where: AnswerScalarWhereInput!
  data: AnswerUpdateManyDataInput!
}

input AnswerUpdateOneRequiredWithoutScoresInput {
  create: AnswerCreateWithoutScoresInput
  update: AnswerUpdateWithoutScoresDataInput
  upsert: AnswerUpsertWithoutScoresInput
  connect: AnswerWhereUniqueInput
}

input AnswerUpdateWithoutQuestionDataInput {
  value: String
  file: FileUpdateOneInput
  email: String
  date: DateTime
  multipleSelection: AnswerUpdateManyInput
  scores: ScoreUpdateManyWithoutAnswerInput
  type: QuestionType
}

input AnswerUpdateWithoutScoresDataInput {
  value: String
  file: FileUpdateOneInput
  email: String
  date: DateTime
  multipleSelection: AnswerUpdateManyInput
  question: QuestionUpdateOneRequiredWithoutAnswersInput
  type: QuestionType
}

input AnswerUpdateWithWhereUniqueNestedInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateDataInput!
}

input AnswerUpdateWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  data: AnswerUpdateWithoutQuestionDataInput!
}

input AnswerUpsertWithoutScoresInput {
  update: AnswerUpdateWithoutScoresDataInput!
  create: AnswerCreateWithoutScoresInput!
}

input AnswerUpsertWithWhereUniqueNestedInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateDataInput!
  create: AnswerCreateInput!
}

input AnswerUpsertWithWhereUniqueWithoutQuestionInput {
  where: AnswerWhereUniqueInput!
  update: AnswerUpdateWithoutQuestionDataInput!
  create: AnswerCreateWithoutQuestionInput!
}

input AnswerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: String
  value_not: String
  value_in: [String!]
  value_not_in: [String!]
  value_lt: String
  value_lte: String
  value_gt: String
  value_gte: String
  value_contains: String
  value_not_contains: String
  value_starts_with: String
  value_not_starts_with: String
  value_ends_with: String
  value_not_ends_with: String
  file: FileWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  multipleSelection_every: AnswerWhereInput
  multipleSelection_some: AnswerWhereInput
  multipleSelection_none: AnswerWhereInput
  question: QuestionWhereInput
  scores_every: ScoreWhereInput
  scores_some: ScoreWhereInput
  scores_none: ScoreWhereInput
  type: QuestionType
  type_not: QuestionType
  type_in: [QuestionType!]
  type_not_in: [QuestionType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
}

input AnswerWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

type ChangePasswordRequest {
  id: ID!
  token: String!
  expireIn: Int!
  url: String!
  used: Boolean!
  user: User!
  createdAt: DateTime
  updatedAt: DateTime
}

type ChangePasswordRequestConnection {
  pageInfo: PageInfo!
  edges: [ChangePasswordRequestEdge]!
  aggregate: AggregateChangePasswordRequest!
}

input ChangePasswordRequestCreateInput {
  id: ID
  token: String!
  expireIn: Int!
  url: String!
  used: Boolean
  user: UserCreateOneInput!
}

type ChangePasswordRequestEdge {
  node: ChangePasswordRequest!
  cursor: String!
}

enum ChangePasswordRequestOrderByInput {
  id_ASC
  id_DESC
  token_ASC
  token_DESC
  expireIn_ASC
  expireIn_DESC
  url_ASC
  url_DESC
  used_ASC
  used_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ChangePasswordRequestPreviousValues {
  id: ID!
  token: String!
  expireIn: Int!
  url: String!
  used: Boolean!
  createdAt: DateTime
  updatedAt: DateTime
}

type ChangePasswordRequestSubscriptionPayload {
  mutation: MutationType!
  node: ChangePasswordRequest
  updatedFields: [String!]
  previousValues: ChangePasswordRequestPreviousValues
}

input ChangePasswordRequestSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChangePasswordRequestWhereInput
  AND: [ChangePasswordRequestSubscriptionWhereInput!]
  OR: [ChangePasswordRequestSubscriptionWhereInput!]
  NOT: [ChangePasswordRequestSubscriptionWhereInput!]
}

input ChangePasswordRequestUpdateInput {
  token: String
  expireIn: Int
  url: String
  used: Boolean
  user: UserUpdateOneRequiredInput
}

input ChangePasswordRequestUpdateManyMutationInput {
  token: String
  expireIn: Int
  url: String
  used: Boolean
}

input ChangePasswordRequestWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  token: String
  token_not: String
  token_in: [String!]
  token_not_in: [String!]
  token_lt: String
  token_lte: String
  token_gt: String
  token_gte: String
  token_contains: String
  token_not_contains: String
  token_starts_with: String
  token_not_starts_with: String
  token_ends_with: String
  token_not_ends_with: String
  expireIn: Int
  expireIn_not: Int
  expireIn_in: [Int!]
  expireIn_not_in: [Int!]
  expireIn_lt: Int
  expireIn_lte: Int
  expireIn_gt: Int
  expireIn_gte: Int
  url: String
  url_not: String
  url_in: [String!]
  url_not_in: [String!]
  url_lt: String
  url_lte: String
  url_gt: String
  url_gte: String
  url_contains: String
  url_not_contains: String
  url_starts_with: String
  url_not_starts_with: String
  url_ends_with: String
  url_not_ends_with: String
  used: Boolean
  used_not: Boolean
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ChangePasswordRequestWhereInput!]
  OR: [ChangePasswordRequestWhereInput!]
  NOT: [ChangePasswordRequestWhereInput!]
}

input ChangePasswordRequestWhereUniqueInput {
  id: ID
  token: String
}

type City {
  id: ID!
  name: String!
  country: Country!
  createdAt: DateTime
  updatedAt: DateTime
}

type CityConnection {
  pageInfo: PageInfo!
  edges: [CityEdge]!
  aggregate: AggregateCity!
}

input CityCreateInput {
  id: ID
  name: String!
  country: CountryCreateOneWithoutCitiesInput!
}

input CityCreateManyWithoutCountryInput {
  create: [CityCreateWithoutCountryInput!]
  connect: [CityWhereUniqueInput!]
}

input CityCreateOneInput {
  create: CityCreateInput
  connect: CityWhereUniqueInput
}

input CityCreateWithoutCountryInput {
  id: ID
  name: String!
}

type CityEdge {
  node: City!
  cursor: String!
}

enum CityOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CityPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input CityScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CityScalarWhereInput!]
  OR: [CityScalarWhereInput!]
  NOT: [CityScalarWhereInput!]
}

type CitySubscriptionPayload {
  mutation: MutationType!
  node: City
  updatedFields: [String!]
  previousValues: CityPreviousValues
}

input CitySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CityWhereInput
  AND: [CitySubscriptionWhereInput!]
  OR: [CitySubscriptionWhereInput!]
  NOT: [CitySubscriptionWhereInput!]
}

input CityUpdateDataInput {
  name: String
  country: CountryUpdateOneRequiredWithoutCitiesInput
}

input CityUpdateInput {
  name: String
  country: CountryUpdateOneRequiredWithoutCitiesInput
}

input CityUpdateManyDataInput {
  name: String
}

input CityUpdateManyMutationInput {
  name: String
}

input CityUpdateManyWithoutCountryInput {
  create: [CityCreateWithoutCountryInput!]
  delete: [CityWhereUniqueInput!]
  connect: [CityWhereUniqueInput!]
  set: [CityWhereUniqueInput!]
  disconnect: [CityWhereUniqueInput!]
  update: [CityUpdateWithWhereUniqueWithoutCountryInput!]
  upsert: [CityUpsertWithWhereUniqueWithoutCountryInput!]
  deleteMany: [CityScalarWhereInput!]
  updateMany: [CityUpdateManyWithWhereNestedInput!]
}

input CityUpdateManyWithWhereNestedInput {
  where: CityScalarWhereInput!
  data: CityUpdateManyDataInput!
}

input CityUpdateOneInput {
  create: CityCreateInput
  update: CityUpdateDataInput
  upsert: CityUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CityWhereUniqueInput
}

input CityUpdateOneRequiredInput {
  create: CityCreateInput
  update: CityUpdateDataInput
  upsert: CityUpsertNestedInput
  connect: CityWhereUniqueInput
}

input CityUpdateWithoutCountryDataInput {
  name: String
}

input CityUpdateWithWhereUniqueWithoutCountryInput {
  where: CityWhereUniqueInput!
  data: CityUpdateWithoutCountryDataInput!
}

input CityUpsertNestedInput {
  update: CityUpdateDataInput!
  create: CityCreateInput!
}

input CityUpsertWithWhereUniqueWithoutCountryInput {
  where: CityWhereUniqueInput!
  update: CityUpdateWithoutCountryDataInput!
  create: CityCreateWithoutCountryInput!
}

input CityWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  country: CountryWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CityWhereInput!]
  OR: [CityWhereInput!]
  NOT: [CityWhereInput!]
}

input CityWhereUniqueInput {
  id: ID
}

type Country {
  id: ID!
  name: String!
  cities(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [City!]
  createdAt: DateTime
  updatedAt: DateTime
}

type CountryConnection {
  pageInfo: PageInfo!
  edges: [CountryEdge]!
  aggregate: AggregateCountry!
}

input CountryCreateInput {
  id: ID
  name: String!
  cities: CityCreateManyWithoutCountryInput
}

input CountryCreateOneInput {
  create: CountryCreateInput
  connect: CountryWhereUniqueInput
}

input CountryCreateOneWithoutCitiesInput {
  create: CountryCreateWithoutCitiesInput
  connect: CountryWhereUniqueInput
}

input CountryCreateWithoutCitiesInput {
  id: ID
  name: String!
}

type CountryEdge {
  node: Country!
  cursor: String!
}

enum CountryOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CountryPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type CountrySubscriptionPayload {
  mutation: MutationType!
  node: Country
  updatedFields: [String!]
  previousValues: CountryPreviousValues
}

input CountrySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CountryWhereInput
  AND: [CountrySubscriptionWhereInput!]
  OR: [CountrySubscriptionWhereInput!]
  NOT: [CountrySubscriptionWhereInput!]
}

input CountryUpdateDataInput {
  name: String
  cities: CityUpdateManyWithoutCountryInput
}

input CountryUpdateInput {
  name: String
  cities: CityUpdateManyWithoutCountryInput
}

input CountryUpdateManyMutationInput {
  name: String
}

input CountryUpdateOneInput {
  create: CountryCreateInput
  update: CountryUpdateDataInput
  upsert: CountryUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: CountryWhereUniqueInput
}

input CountryUpdateOneRequiredInput {
  create: CountryCreateInput
  update: CountryUpdateDataInput
  upsert: CountryUpsertNestedInput
  connect: CountryWhereUniqueInput
}

input CountryUpdateOneRequiredWithoutCitiesInput {
  create: CountryCreateWithoutCitiesInput
  update: CountryUpdateWithoutCitiesDataInput
  upsert: CountryUpsertWithoutCitiesInput
  connect: CountryWhereUniqueInput
}

input CountryUpdateWithoutCitiesDataInput {
  name: String
}

input CountryUpsertNestedInput {
  update: CountryUpdateDataInput!
  create: CountryCreateInput!
}

input CountryUpsertWithoutCitiesInput {
  update: CountryUpdateWithoutCitiesDataInput!
  create: CountryCreateWithoutCitiesInput!
}

input CountryWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  cities_every: CityWhereInput
  cities_some: CityWhereInput
  cities_none: CityWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CountryWhereInput!]
  OR: [CountryWhereInput!]
  NOT: [CountryWhereInput!]
}

input CountryWhereUniqueInput {
  id: ID
  name: String
}

type Currency {
  id: ID!
  name: String!
  symbol: String!
}

type CurrencyConnection {
  pageInfo: PageInfo!
  edges: [CurrencyEdge]!
  aggregate: AggregateCurrency!
}

input CurrencyCreateInput {
  id: ID
  name: String!
  symbol: String!
}

input CurrencyCreateOneInput {
  create: CurrencyCreateInput
  connect: CurrencyWhereUniqueInput
}

type CurrencyEdge {
  node: Currency!
  cursor: String!
}

enum CurrencyOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  symbol_ASC
  symbol_DESC
}

type CurrencyPreviousValues {
  id: ID!
  name: String!
  symbol: String!
}

type CurrencySubscriptionPayload {
  mutation: MutationType!
  node: Currency
  updatedFields: [String!]
  previousValues: CurrencyPreviousValues
}

input CurrencySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CurrencyWhereInput
  AND: [CurrencySubscriptionWhereInput!]
  OR: [CurrencySubscriptionWhereInput!]
  NOT: [CurrencySubscriptionWhereInput!]
}

input CurrencyUpdateDataInput {
  name: String
  symbol: String
}

input CurrencyUpdateInput {
  name: String
  symbol: String
}

input CurrencyUpdateManyMutationInput {
  name: String
  symbol: String
}

input CurrencyUpdateOneRequiredInput {
  create: CurrencyCreateInput
  update: CurrencyUpdateDataInput
  upsert: CurrencyUpsertNestedInput
  connect: CurrencyWhereUniqueInput
}

input CurrencyUpsertNestedInput {
  update: CurrencyUpdateDataInput!
  create: CurrencyCreateInput!
}

input CurrencyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  symbol: String
  symbol_not: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_lt: String
  symbol_lte: String
  symbol_gt: String
  symbol_gte: String
  symbol_contains: String
  symbol_not_contains: String
  symbol_starts_with: String
  symbol_not_starts_with: String
  symbol_ends_with: String
  symbol_not_ends_with: String
  AND: [CurrencyWhereInput!]
  OR: [CurrencyWhereInput!]
  NOT: [CurrencyWhereInput!]
}

input CurrencyWhereUniqueInput {
  id: ID
  name: String
  symbol: String
}

scalar DateTime

type Expertise {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type ExpertiseConnection {
  pageInfo: PageInfo!
  edges: [ExpertiseEdge]!
  aggregate: AggregateExpertise!
}

input ExpertiseCreateInput {
  id: ID
  name: String!
}

input ExpertiseCreateManyInput {
  create: [ExpertiseCreateInput!]
  connect: [ExpertiseWhereUniqueInput!]
}

type ExpertiseEdge {
  node: Expertise!
  cursor: String!
}

enum ExpertiseOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExpertisePreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input ExpertiseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExpertiseScalarWhereInput!]
  OR: [ExpertiseScalarWhereInput!]
  NOT: [ExpertiseScalarWhereInput!]
}

type ExpertiseSubscriptionPayload {
  mutation: MutationType!
  node: Expertise
  updatedFields: [String!]
  previousValues: ExpertisePreviousValues
}

input ExpertiseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExpertiseWhereInput
  AND: [ExpertiseSubscriptionWhereInput!]
  OR: [ExpertiseSubscriptionWhereInput!]
  NOT: [ExpertiseSubscriptionWhereInput!]
}

input ExpertiseUpdateDataInput {
  name: String
}

input ExpertiseUpdateInput {
  name: String
}

input ExpertiseUpdateManyDataInput {
  name: String
}

input ExpertiseUpdateManyInput {
  create: [ExpertiseCreateInput!]
  update: [ExpertiseUpdateWithWhereUniqueNestedInput!]
  upsert: [ExpertiseUpsertWithWhereUniqueNestedInput!]
  delete: [ExpertiseWhereUniqueInput!]
  connect: [ExpertiseWhereUniqueInput!]
  set: [ExpertiseWhereUniqueInput!]
  disconnect: [ExpertiseWhereUniqueInput!]
  deleteMany: [ExpertiseScalarWhereInput!]
  updateMany: [ExpertiseUpdateManyWithWhereNestedInput!]
}

input ExpertiseUpdateManyMutationInput {
  name: String
}

input ExpertiseUpdateManyWithWhereNestedInput {
  where: ExpertiseScalarWhereInput!
  data: ExpertiseUpdateManyDataInput!
}

input ExpertiseUpdateWithWhereUniqueNestedInput {
  where: ExpertiseWhereUniqueInput!
  data: ExpertiseUpdateDataInput!
}

input ExpertiseUpsertWithWhereUniqueNestedInput {
  where: ExpertiseWhereUniqueInput!
  update: ExpertiseUpdateDataInput!
  create: ExpertiseCreateInput!
}

input ExpertiseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExpertiseWhereInput!]
  OR: [ExpertiseWhereInput!]
  NOT: [ExpertiseWhereInput!]
}

input ExpertiseWhereUniqueInput {
  id: ID
  name: String
}

type File {
  id: ID!
  path: String!
  filename: String!
  mimetype: String!
  encoding: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: ID
  path: String!
  filename: String!
  mimetype: String!
  encoding: String!
}

input FileCreateOneInput {
  create: FileCreateInput
  connect: FileWhereUniqueInput
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  path_ASC
  path_DESC
  filename_ASC
  filename_DESC
  mimetype_ASC
  mimetype_DESC
  encoding_ASC
  encoding_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FilePreviousValues {
  id: ID!
  path: String!
  filename: String!
  mimetype: String!
  encoding: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateDataInput {
  path: String
  filename: String
  mimetype: String
  encoding: String
}

input FileUpdateInput {
  path: String
  filename: String
  mimetype: String
  encoding: String
}

input FileUpdateManyMutationInput {
  path: String
  filename: String
  mimetype: String
  encoding: String
}

input FileUpdateOneInput {
  create: FileCreateInput
  update: FileUpdateDataInput
  upsert: FileUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: FileWhereUniqueInput
}

input FileUpdateOneRequiredInput {
  create: FileCreateInput
  update: FileUpdateDataInput
  upsert: FileUpsertNestedInput
  connect: FileWhereUniqueInput
}

input FileUpsertNestedInput {
  update: FileUpdateDataInput!
  create: FileCreateInput!
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  filename: String
  filename_not: String
  filename_in: [String!]
  filename_not_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_gt: String
  filename_gte: String
  filename_contains: String
  filename_not_contains: String
  filename_starts_with: String
  filename_not_starts_with: String
  filename_ends_with: String
  filename_not_ends_with: String
  mimetype: String
  mimetype_not: String
  mimetype_in: [String!]
  mimetype_not_in: [String!]
  mimetype_lt: String
  mimetype_lte: String
  mimetype_gt: String
  mimetype_gte: String
  mimetype_contains: String
  mimetype_not_contains: String
  mimetype_starts_with: String
  mimetype_not_starts_with: String
  mimetype_ends_with: String
  mimetype_not_ends_with: String
  encoding: String
  encoding_not: String
  encoding_in: [String!]
  encoding_not_in: [String!]
  encoding_lt: String
  encoding_lte: String
  encoding_gt: String
  encoding_gte: String
  encoding_contains: String
  encoding_not_contains: String
  encoding_starts_with: String
  encoding_not_starts_with: String
  encoding_ends_with: String
  encoding_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
  path: String
}

type Form {
  id: ID!
  workflow: Workflow!
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question!]
  judges(where: WorkflowJudgeWhereInput, orderBy: WorkflowJudgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkflowJudge!]
  responses(where: FormResponseWhereInput, orderBy: FormResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FormResponse!]
  createdAt: DateTime
  updatedAt: DateTime
}

type FormConnection {
  pageInfo: PageInfo!
  edges: [FormEdge]!
  aggregate: AggregateForm!
}

input FormCreateInput {
  id: ID
  workflow: WorkflowCreateOneWithoutFormsInput!
  questions: QuestionCreateManyWithoutFormInput
  judges: WorkflowJudgeCreateManyInput
  responses: FormResponseCreateManyWithoutFormInput
}

input FormCreateManyWithoutWorkflowInput {
  create: [FormCreateWithoutWorkflowInput!]
  connect: [FormWhereUniqueInput!]
}

input FormCreateOneWithoutQuestionsInput {
  create: FormCreateWithoutQuestionsInput
  connect: FormWhereUniqueInput
}

input FormCreateOneWithoutResponsesInput {
  create: FormCreateWithoutResponsesInput
  connect: FormWhereUniqueInput
}

input FormCreateWithoutQuestionsInput {
  id: ID
  workflow: WorkflowCreateOneWithoutFormsInput!
  judges: WorkflowJudgeCreateManyInput
  responses: FormResponseCreateManyWithoutFormInput
}

input FormCreateWithoutResponsesInput {
  id: ID
  workflow: WorkflowCreateOneWithoutFormsInput!
  questions: QuestionCreateManyWithoutFormInput
  judges: WorkflowJudgeCreateManyInput
}

input FormCreateWithoutWorkflowInput {
  id: ID
  questions: QuestionCreateManyWithoutFormInput
  judges: WorkflowJudgeCreateManyInput
  responses: FormResponseCreateManyWithoutFormInput
}

type FormEdge {
  node: Form!
  cursor: String!
}

enum FormOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FormPreviousValues {
  id: ID!
  createdAt: DateTime
  updatedAt: DateTime
}

type FormResponse {
  id: ID!
  form: Form!
  user: User!
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer!]
  scores(where: FormScoreWhereInput, orderBy: FormScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FormScore!]
  status: ProcessState
  createdAt: DateTime
  updatedAt: DateTime
}

type FormResponseConnection {
  pageInfo: PageInfo!
  edges: [FormResponseEdge]!
  aggregate: AggregateFormResponse!
}

input FormResponseCreateInput {
  id: ID
  form: FormCreateOneWithoutResponsesInput!
  user: UserCreateOneInput!
  answers: AnswerCreateManyInput
  scores: FormScoreCreateManyWithoutResponseInput
  status: ProcessState
}

input FormResponseCreateManyWithoutFormInput {
  create: [FormResponseCreateWithoutFormInput!]
  connect: [FormResponseWhereUniqueInput!]
}

input FormResponseCreateOneWithoutScoresInput {
  create: FormResponseCreateWithoutScoresInput
  connect: FormResponseWhereUniqueInput
}

input FormResponseCreateWithoutFormInput {
  id: ID
  user: UserCreateOneInput!
  answers: AnswerCreateManyInput
  scores: FormScoreCreateManyWithoutResponseInput
  status: ProcessState
}

input FormResponseCreateWithoutScoresInput {
  id: ID
  form: FormCreateOneWithoutResponsesInput!
  user: UserCreateOneInput!
  answers: AnswerCreateManyInput
  status: ProcessState
}

type FormResponseEdge {
  node: FormResponse!
  cursor: String!
}

enum FormResponseOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FormResponsePreviousValues {
  id: ID!
  status: ProcessState
  createdAt: DateTime
  updatedAt: DateTime
}

input FormResponseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FormResponseScalarWhereInput!]
  OR: [FormResponseScalarWhereInput!]
  NOT: [FormResponseScalarWhereInput!]
}

type FormResponseSubscriptionPayload {
  mutation: MutationType!
  node: FormResponse
  updatedFields: [String!]
  previousValues: FormResponsePreviousValues
}

input FormResponseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FormResponseWhereInput
  AND: [FormResponseSubscriptionWhereInput!]
  OR: [FormResponseSubscriptionWhereInput!]
  NOT: [FormResponseSubscriptionWhereInput!]
}

input FormResponseUpdateInput {
  form: FormUpdateOneRequiredWithoutResponsesInput
  user: UserUpdateOneRequiredInput
  answers: AnswerUpdateManyInput
  scores: FormScoreUpdateManyWithoutResponseInput
  status: ProcessState
}

input FormResponseUpdateManyDataInput {
  status: ProcessState
}

input FormResponseUpdateManyMutationInput {
  status: ProcessState
}

input FormResponseUpdateManyWithoutFormInput {
  create: [FormResponseCreateWithoutFormInput!]
  delete: [FormResponseWhereUniqueInput!]
  connect: [FormResponseWhereUniqueInput!]
  set: [FormResponseWhereUniqueInput!]
  disconnect: [FormResponseWhereUniqueInput!]
  update: [FormResponseUpdateWithWhereUniqueWithoutFormInput!]
  upsert: [FormResponseUpsertWithWhereUniqueWithoutFormInput!]
  deleteMany: [FormResponseScalarWhereInput!]
  updateMany: [FormResponseUpdateManyWithWhereNestedInput!]
}

input FormResponseUpdateManyWithWhereNestedInput {
  where: FormResponseScalarWhereInput!
  data: FormResponseUpdateManyDataInput!
}

input FormResponseUpdateOneRequiredWithoutScoresInput {
  create: FormResponseCreateWithoutScoresInput
  update: FormResponseUpdateWithoutScoresDataInput
  upsert: FormResponseUpsertWithoutScoresInput
  connect: FormResponseWhereUniqueInput
}

input FormResponseUpdateWithoutFormDataInput {
  user: UserUpdateOneRequiredInput
  answers: AnswerUpdateManyInput
  scores: FormScoreUpdateManyWithoutResponseInput
  status: ProcessState
}

input FormResponseUpdateWithoutScoresDataInput {
  form: FormUpdateOneRequiredWithoutResponsesInput
  user: UserUpdateOneRequiredInput
  answers: AnswerUpdateManyInput
  status: ProcessState
}

input FormResponseUpdateWithWhereUniqueWithoutFormInput {
  where: FormResponseWhereUniqueInput!
  data: FormResponseUpdateWithoutFormDataInput!
}

input FormResponseUpsertWithoutScoresInput {
  update: FormResponseUpdateWithoutScoresDataInput!
  create: FormResponseCreateWithoutScoresInput!
}

input FormResponseUpsertWithWhereUniqueWithoutFormInput {
  where: FormResponseWhereUniqueInput!
  update: FormResponseUpdateWithoutFormDataInput!
  create: FormResponseCreateWithoutFormInput!
}

input FormResponseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  form: FormWhereInput
  user: UserWhereInput
  answers_every: AnswerWhereInput
  answers_some: AnswerWhereInput
  answers_none: AnswerWhereInput
  scores_every: FormScoreWhereInput
  scores_some: FormScoreWhereInput
  scores_none: FormScoreWhereInput
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FormResponseWhereInput!]
  OR: [FormResponseWhereInput!]
  NOT: [FormResponseWhereInput!]
}

input FormResponseWhereUniqueInput {
  id: ID
}

input FormScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FormScalarWhereInput!]
  OR: [FormScalarWhereInput!]
  NOT: [FormScalarWhereInput!]
}

type FormScore {
  id: ID!
  response: FormResponse!
  judge: User!
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score!]
  status: ProcessState
  createdAt: DateTime
  updatedAt: DateTime
}

type FormScoreConnection {
  pageInfo: PageInfo!
  edges: [FormScoreEdge]!
  aggregate: AggregateFormScore!
}

input FormScoreCreateInput {
  id: ID
  response: FormResponseCreateOneWithoutScoresInput!
  judge: UserCreateOneInput!
  scores: ScoreCreateManyInput
  status: ProcessState
}

input FormScoreCreateManyWithoutResponseInput {
  create: [FormScoreCreateWithoutResponseInput!]
  connect: [FormScoreWhereUniqueInput!]
}

input FormScoreCreateWithoutResponseInput {
  id: ID
  judge: UserCreateOneInput!
  scores: ScoreCreateManyInput
  status: ProcessState
}

type FormScoreEdge {
  node: FormScore!
  cursor: String!
}

enum FormScoreOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FormScorePreviousValues {
  id: ID!
  status: ProcessState
  createdAt: DateTime
  updatedAt: DateTime
}

input FormScoreScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FormScoreScalarWhereInput!]
  OR: [FormScoreScalarWhereInput!]
  NOT: [FormScoreScalarWhereInput!]
}

type FormScoreSubscriptionPayload {
  mutation: MutationType!
  node: FormScore
  updatedFields: [String!]
  previousValues: FormScorePreviousValues
}

input FormScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FormScoreWhereInput
  AND: [FormScoreSubscriptionWhereInput!]
  OR: [FormScoreSubscriptionWhereInput!]
  NOT: [FormScoreSubscriptionWhereInput!]
}

input FormScoreUpdateInput {
  response: FormResponseUpdateOneRequiredWithoutScoresInput
  judge: UserUpdateOneRequiredInput
  scores: ScoreUpdateManyInput
  status: ProcessState
}

input FormScoreUpdateManyDataInput {
  status: ProcessState
}

input FormScoreUpdateManyMutationInput {
  status: ProcessState
}

input FormScoreUpdateManyWithoutResponseInput {
  create: [FormScoreCreateWithoutResponseInput!]
  delete: [FormScoreWhereUniqueInput!]
  connect: [FormScoreWhereUniqueInput!]
  set: [FormScoreWhereUniqueInput!]
  disconnect: [FormScoreWhereUniqueInput!]
  update: [FormScoreUpdateWithWhereUniqueWithoutResponseInput!]
  upsert: [FormScoreUpsertWithWhereUniqueWithoutResponseInput!]
  deleteMany: [FormScoreScalarWhereInput!]
  updateMany: [FormScoreUpdateManyWithWhereNestedInput!]
}

input FormScoreUpdateManyWithWhereNestedInput {
  where: FormScoreScalarWhereInput!
  data: FormScoreUpdateManyDataInput!
}

input FormScoreUpdateWithoutResponseDataInput {
  judge: UserUpdateOneRequiredInput
  scores: ScoreUpdateManyInput
  status: ProcessState
}

input FormScoreUpdateWithWhereUniqueWithoutResponseInput {
  where: FormScoreWhereUniqueInput!
  data: FormScoreUpdateWithoutResponseDataInput!
}

input FormScoreUpsertWithWhereUniqueWithoutResponseInput {
  where: FormScoreWhereUniqueInput!
  update: FormScoreUpdateWithoutResponseDataInput!
  create: FormScoreCreateWithoutResponseInput!
}

input FormScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  response: FormResponseWhereInput
  judge: UserWhereInput
  scores_every: ScoreWhereInput
  scores_some: ScoreWhereInput
  scores_none: ScoreWhereInput
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FormScoreWhereInput!]
  OR: [FormScoreWhereInput!]
  NOT: [FormScoreWhereInput!]
}

input FormScoreWhereUniqueInput {
  id: ID
}

type FormSubscriptionPayload {
  mutation: MutationType!
  node: Form
  updatedFields: [String!]
  previousValues: FormPreviousValues
}

input FormSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FormWhereInput
  AND: [FormSubscriptionWhereInput!]
  OR: [FormSubscriptionWhereInput!]
  NOT: [FormSubscriptionWhereInput!]
}

input FormUpdateInput {
  workflow: WorkflowUpdateOneRequiredWithoutFormsInput
  questions: QuestionUpdateManyWithoutFormInput
  judges: WorkflowJudgeUpdateManyInput
  responses: FormResponseUpdateManyWithoutFormInput
}

input FormUpdateManyWithoutWorkflowInput {
  create: [FormCreateWithoutWorkflowInput!]
  delete: [FormWhereUniqueInput!]
  connect: [FormWhereUniqueInput!]
  set: [FormWhereUniqueInput!]
  disconnect: [FormWhereUniqueInput!]
  update: [FormUpdateWithWhereUniqueWithoutWorkflowInput!]
  upsert: [FormUpsertWithWhereUniqueWithoutWorkflowInput!]
  deleteMany: [FormScalarWhereInput!]
}

input FormUpdateOneRequiredWithoutQuestionsInput {
  create: FormCreateWithoutQuestionsInput
  update: FormUpdateWithoutQuestionsDataInput
  upsert: FormUpsertWithoutQuestionsInput
  connect: FormWhereUniqueInput
}

input FormUpdateOneRequiredWithoutResponsesInput {
  create: FormCreateWithoutResponsesInput
  update: FormUpdateWithoutResponsesDataInput
  upsert: FormUpsertWithoutResponsesInput
  connect: FormWhereUniqueInput
}

input FormUpdateWithoutQuestionsDataInput {
  workflow: WorkflowUpdateOneRequiredWithoutFormsInput
  judges: WorkflowJudgeUpdateManyInput
  responses: FormResponseUpdateManyWithoutFormInput
}

input FormUpdateWithoutResponsesDataInput {
  workflow: WorkflowUpdateOneRequiredWithoutFormsInput
  questions: QuestionUpdateManyWithoutFormInput
  judges: WorkflowJudgeUpdateManyInput
}

input FormUpdateWithoutWorkflowDataInput {
  questions: QuestionUpdateManyWithoutFormInput
  judges: WorkflowJudgeUpdateManyInput
  responses: FormResponseUpdateManyWithoutFormInput
}

input FormUpdateWithWhereUniqueWithoutWorkflowInput {
  where: FormWhereUniqueInput!
  data: FormUpdateWithoutWorkflowDataInput!
}

input FormUpsertWithoutQuestionsInput {
  update: FormUpdateWithoutQuestionsDataInput!
  create: FormCreateWithoutQuestionsInput!
}

input FormUpsertWithoutResponsesInput {
  update: FormUpdateWithoutResponsesDataInput!
  create: FormCreateWithoutResponsesInput!
}

input FormUpsertWithWhereUniqueWithoutWorkflowInput {
  where: FormWhereUniqueInput!
  update: FormUpdateWithoutWorkflowDataInput!
  create: FormCreateWithoutWorkflowInput!
}

input FormWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  workflow: WorkflowWhereInput
  questions_every: QuestionWhereInput
  questions_some: QuestionWhereInput
  questions_none: QuestionWhereInput
  judges_every: WorkflowJudgeWhereInput
  judges_some: WorkflowJudgeWhereInput
  judges_none: WorkflowJudgeWhereInput
  responses_every: FormResponseWhereInput
  responses_some: FormResponseWhereInput
  responses_none: FormResponseWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [FormWhereInput!]
  OR: [FormWhereInput!]
  NOT: [FormWhereInput!]
}

input FormWhereUniqueInput {
  id: ID
}

type Invitation {
  id: ID!
  inviter: User!
  invitee: User!
  link: String!
  type: InviteType!
  message: String
  status: ProcessState!
}

type InvitationConnection {
  pageInfo: PageInfo!
  edges: [InvitationEdge]!
  aggregate: AggregateInvitation!
}

input InvitationCreateInput {
  id: ID
  inviter: UserCreateOneWithoutOutgoingInvitationsInput!
  invitee: UserCreateOneWithoutInvitationsInput!
  link: String!
  type: InviteType
  message: String
  status: ProcessState
}

input InvitationCreateManyWithoutInviteeInput {
  create: [InvitationCreateWithoutInviteeInput!]
  connect: [InvitationWhereUniqueInput!]
}

input InvitationCreateManyWithoutInviterInput {
  create: [InvitationCreateWithoutInviterInput!]
  connect: [InvitationWhereUniqueInput!]
}

input InvitationCreateWithoutInviteeInput {
  id: ID
  inviter: UserCreateOneWithoutOutgoingInvitationsInput!
  link: String!
  type: InviteType
  message: String
  status: ProcessState
}

input InvitationCreateWithoutInviterInput {
  id: ID
  invitee: UserCreateOneWithoutInvitationsInput!
  link: String!
  type: InviteType
  message: String
  status: ProcessState
}

type InvitationEdge {
  node: Invitation!
  cursor: String!
}

enum InvitationOrderByInput {
  id_ASC
  id_DESC
  link_ASC
  link_DESC
  type_ASC
  type_DESC
  message_ASC
  message_DESC
  status_ASC
  status_DESC
}

type InvitationPreviousValues {
  id: ID!
  link: String!
  type: InviteType!
  message: String
  status: ProcessState!
}

input InvitationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  type: InviteType
  type_not: InviteType
  type_in: [InviteType!]
  type_not_in: [InviteType!]
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  AND: [InvitationScalarWhereInput!]
  OR: [InvitationScalarWhereInput!]
  NOT: [InvitationScalarWhereInput!]
}

type InvitationSubscriptionPayload {
  mutation: MutationType!
  node: Invitation
  updatedFields: [String!]
  previousValues: InvitationPreviousValues
}

input InvitationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: InvitationWhereInput
  AND: [InvitationSubscriptionWhereInput!]
  OR: [InvitationSubscriptionWhereInput!]
  NOT: [InvitationSubscriptionWhereInput!]
}

input InvitationUpdateInput {
  inviter: UserUpdateOneRequiredWithoutOutgoingInvitationsInput
  invitee: UserUpdateOneRequiredWithoutInvitationsInput
  link: String
  type: InviteType
  message: String
  status: ProcessState
}

input InvitationUpdateManyDataInput {
  link: String
  type: InviteType
  message: String
  status: ProcessState
}

input InvitationUpdateManyMutationInput {
  link: String
  type: InviteType
  message: String
  status: ProcessState
}

input InvitationUpdateManyWithoutInviteeInput {
  create: [InvitationCreateWithoutInviteeInput!]
  delete: [InvitationWhereUniqueInput!]
  connect: [InvitationWhereUniqueInput!]
  set: [InvitationWhereUniqueInput!]
  disconnect: [InvitationWhereUniqueInput!]
  update: [InvitationUpdateWithWhereUniqueWithoutInviteeInput!]
  upsert: [InvitationUpsertWithWhereUniqueWithoutInviteeInput!]
  deleteMany: [InvitationScalarWhereInput!]
  updateMany: [InvitationUpdateManyWithWhereNestedInput!]
}

input InvitationUpdateManyWithoutInviterInput {
  create: [InvitationCreateWithoutInviterInput!]
  delete: [InvitationWhereUniqueInput!]
  connect: [InvitationWhereUniqueInput!]
  set: [InvitationWhereUniqueInput!]
  disconnect: [InvitationWhereUniqueInput!]
  update: [InvitationUpdateWithWhereUniqueWithoutInviterInput!]
  upsert: [InvitationUpsertWithWhereUniqueWithoutInviterInput!]
  deleteMany: [InvitationScalarWhereInput!]
  updateMany: [InvitationUpdateManyWithWhereNestedInput!]
}

input InvitationUpdateManyWithWhereNestedInput {
  where: InvitationScalarWhereInput!
  data: InvitationUpdateManyDataInput!
}

input InvitationUpdateWithoutInviteeDataInput {
  inviter: UserUpdateOneRequiredWithoutOutgoingInvitationsInput
  link: String
  type: InviteType
  message: String
  status: ProcessState
}

input InvitationUpdateWithoutInviterDataInput {
  invitee: UserUpdateOneRequiredWithoutInvitationsInput
  link: String
  type: InviteType
  message: String
  status: ProcessState
}

input InvitationUpdateWithWhereUniqueWithoutInviteeInput {
  where: InvitationWhereUniqueInput!
  data: InvitationUpdateWithoutInviteeDataInput!
}

input InvitationUpdateWithWhereUniqueWithoutInviterInput {
  where: InvitationWhereUniqueInput!
  data: InvitationUpdateWithoutInviterDataInput!
}

input InvitationUpsertWithWhereUniqueWithoutInviteeInput {
  where: InvitationWhereUniqueInput!
  update: InvitationUpdateWithoutInviteeDataInput!
  create: InvitationCreateWithoutInviteeInput!
}

input InvitationUpsertWithWhereUniqueWithoutInviterInput {
  where: InvitationWhereUniqueInput!
  update: InvitationUpdateWithoutInviterDataInput!
  create: InvitationCreateWithoutInviterInput!
}

input InvitationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  inviter: UserWhereInput
  invitee: UserWhereInput
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  type: InviteType
  type_not: InviteType
  type_in: [InviteType!]
  type_not_in: [InviteType!]
  message: String
  message_not: String
  message_in: [String!]
  message_not_in: [String!]
  message_lt: String
  message_lte: String
  message_gt: String
  message_gte: String
  message_contains: String
  message_not_contains: String
  message_starts_with: String
  message_not_starts_with: String
  message_ends_with: String
  message_not_ends_with: String
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  AND: [InvitationWhereInput!]
  OR: [InvitationWhereInput!]
  NOT: [InvitationWhereInput!]
}

input InvitationWhereUniqueInput {
  id: ID
}

enum InviteType {
  APPLY
  JUDGING
  MANAGE
}

scalar Long

type Mutation {
  createAdmin(data: AdminCreateInput!): Admin!
  updateAdmin(data: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin
  updateManyAdmins(data: AdminUpdateManyMutationInput!, where: AdminWhereInput): BatchPayload!
  upsertAdmin(where: AdminWhereUniqueInput!, create: AdminCreateInput!, update: AdminUpdateInput!): Admin!
  deleteAdmin(where: AdminWhereUniqueInput!): Admin
  deleteManyAdmins(where: AdminWhereInput): BatchPayload!
  createAnswer(data: AnswerCreateInput!): Answer!
  updateAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer
  updateManyAnswers(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): BatchPayload!
  upsertAnswer(where: AnswerWhereUniqueInput!, create: AnswerCreateInput!, update: AnswerUpdateInput!): Answer!
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteManyAnswers(where: AnswerWhereInput): BatchPayload!
  createChangePasswordRequest(data: ChangePasswordRequestCreateInput!): ChangePasswordRequest!
  updateChangePasswordRequest(data: ChangePasswordRequestUpdateInput!, where: ChangePasswordRequestWhereUniqueInput!): ChangePasswordRequest
  updateManyChangePasswordRequests(data: ChangePasswordRequestUpdateManyMutationInput!, where: ChangePasswordRequestWhereInput): BatchPayload!
  upsertChangePasswordRequest(where: ChangePasswordRequestWhereUniqueInput!, create: ChangePasswordRequestCreateInput!, update: ChangePasswordRequestUpdateInput!): ChangePasswordRequest!
  deleteChangePasswordRequest(where: ChangePasswordRequestWhereUniqueInput!): ChangePasswordRequest
  deleteManyChangePasswordRequests(where: ChangePasswordRequestWhereInput): BatchPayload!
  createCity(data: CityCreateInput!): City!
  updateCity(data: CityUpdateInput!, where: CityWhereUniqueInput!): City
  updateManyCities(data: CityUpdateManyMutationInput!, where: CityWhereInput): BatchPayload!
  upsertCity(where: CityWhereUniqueInput!, create: CityCreateInput!, update: CityUpdateInput!): City!
  deleteCity(where: CityWhereUniqueInput!): City
  deleteManyCities(where: CityWhereInput): BatchPayload!
  createCountry(data: CountryCreateInput!): Country!
  updateCountry(data: CountryUpdateInput!, where: CountryWhereUniqueInput!): Country
  updateManyCountries(data: CountryUpdateManyMutationInput!, where: CountryWhereInput): BatchPayload!
  upsertCountry(where: CountryWhereUniqueInput!, create: CountryCreateInput!, update: CountryUpdateInput!): Country!
  deleteCountry(where: CountryWhereUniqueInput!): Country
  deleteManyCountries(where: CountryWhereInput): BatchPayload!
  createCurrency(data: CurrencyCreateInput!): Currency!
  updateCurrency(data: CurrencyUpdateInput!, where: CurrencyWhereUniqueInput!): Currency
  updateManyCurrencies(data: CurrencyUpdateManyMutationInput!, where: CurrencyWhereInput): BatchPayload!
  upsertCurrency(where: CurrencyWhereUniqueInput!, create: CurrencyCreateInput!, update: CurrencyUpdateInput!): Currency!
  deleteCurrency(where: CurrencyWhereUniqueInput!): Currency
  deleteManyCurrencies(where: CurrencyWhereInput): BatchPayload!
  createExpertise(data: ExpertiseCreateInput!): Expertise!
  updateExpertise(data: ExpertiseUpdateInput!, where: ExpertiseWhereUniqueInput!): Expertise
  updateManyExpertises(data: ExpertiseUpdateManyMutationInput!, where: ExpertiseWhereInput): BatchPayload!
  upsertExpertise(where: ExpertiseWhereUniqueInput!, create: ExpertiseCreateInput!, update: ExpertiseUpdateInput!): Expertise!
  deleteExpertise(where: ExpertiseWhereUniqueInput!): Expertise
  deleteManyExpertises(where: ExpertiseWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createForm(data: FormCreateInput!): Form!
  updateForm(data: FormUpdateInput!, where: FormWhereUniqueInput!): Form
  upsertForm(where: FormWhereUniqueInput!, create: FormCreateInput!, update: FormUpdateInput!): Form!
  deleteForm(where: FormWhereUniqueInput!): Form
  deleteManyForms(where: FormWhereInput): BatchPayload!
  createFormResponse(data: FormResponseCreateInput!): FormResponse!
  updateFormResponse(data: FormResponseUpdateInput!, where: FormResponseWhereUniqueInput!): FormResponse
  updateManyFormResponses(data: FormResponseUpdateManyMutationInput!, where: FormResponseWhereInput): BatchPayload!
  upsertFormResponse(where: FormResponseWhereUniqueInput!, create: FormResponseCreateInput!, update: FormResponseUpdateInput!): FormResponse!
  deleteFormResponse(where: FormResponseWhereUniqueInput!): FormResponse
  deleteManyFormResponses(where: FormResponseWhereInput): BatchPayload!
  createFormScore(data: FormScoreCreateInput!): FormScore!
  updateFormScore(data: FormScoreUpdateInput!, where: FormScoreWhereUniqueInput!): FormScore
  updateManyFormScores(data: FormScoreUpdateManyMutationInput!, where: FormScoreWhereInput): BatchPayload!
  upsertFormScore(where: FormScoreWhereUniqueInput!, create: FormScoreCreateInput!, update: FormScoreUpdateInput!): FormScore!
  deleteFormScore(where: FormScoreWhereUniqueInput!): FormScore
  deleteManyFormScores(where: FormScoreWhereInput): BatchPayload!
  createInvitation(data: InvitationCreateInput!): Invitation!
  updateInvitation(data: InvitationUpdateInput!, where: InvitationWhereUniqueInput!): Invitation
  updateManyInvitations(data: InvitationUpdateManyMutationInput!, where: InvitationWhereInput): BatchPayload!
  upsertInvitation(where: InvitationWhereUniqueInput!, create: InvitationCreateInput!, update: InvitationUpdateInput!): Invitation!
  deleteInvitation(where: InvitationWhereUniqueInput!): Invitation
  deleteManyInvitations(where: InvitationWhereInput): BatchPayload!
  createOrganization(data: OrganizationCreateInput!): Organization!
  updateOrganization(data: OrganizationUpdateInput!, where: OrganizationWhereUniqueInput!): Organization
  updateManyOrganizations(data: OrganizationUpdateManyMutationInput!, where: OrganizationWhereInput): BatchPayload!
  upsertOrganization(where: OrganizationWhereUniqueInput!, create: OrganizationCreateInput!, update: OrganizationUpdateInput!): Organization!
  deleteOrganization(where: OrganizationWhereUniqueInput!): Organization
  deleteManyOrganizations(where: OrganizationWhereInput): BatchPayload!
  createOrganizationStaff(data: OrganizationStaffCreateInput!): OrganizationStaff!
  updateOrganizationStaff(data: OrganizationStaffUpdateInput!, where: OrganizationStaffWhereUniqueInput!): OrganizationStaff
  updateManyOrganizationStaffs(data: OrganizationStaffUpdateManyMutationInput!, where: OrganizationStaffWhereInput): BatchPayload!
  upsertOrganizationStaff(where: OrganizationStaffWhereUniqueInput!, create: OrganizationStaffCreateInput!, update: OrganizationStaffUpdateInput!): OrganizationStaff!
  deleteOrganizationStaff(where: OrganizationStaffWhereUniqueInput!): OrganizationStaff
  deleteManyOrganizationStaffs(where: OrganizationStaffWhereInput): BatchPayload!
  createPaymentMethod(data: PaymentMethodCreateInput!): PaymentMethod!
  updatePaymentMethod(data: PaymentMethodUpdateInput!, where: PaymentMethodWhereUniqueInput!): PaymentMethod
  updateManyPaymentMethods(data: PaymentMethodUpdateManyMutationInput!, where: PaymentMethodWhereInput): BatchPayload!
  upsertPaymentMethod(where: PaymentMethodWhereUniqueInput!, create: PaymentMethodCreateInput!, update: PaymentMethodUpdateInput!): PaymentMethod!
  deletePaymentMethod(where: PaymentMethodWhereUniqueInput!): PaymentMethod
  deleteManyPaymentMethods(where: PaymentMethodWhereInput): BatchPayload!
  createQuestion(data: QuestionCreateInput!): Question!
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateManyQuestions(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): BatchPayload!
  upsertQuestion(where: QuestionWhereUniqueInput!, create: QuestionCreateInput!, update: QuestionUpdateInput!): Question!
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteManyQuestions(where: QuestionWhereInput): BatchPayload!
  createScore(data: ScoreCreateInput!): Score!
  updateScore(data: ScoreUpdateInput!, where: ScoreWhereUniqueInput!): Score
  updateManyScores(data: ScoreUpdateManyMutationInput!, where: ScoreWhereInput): BatchPayload!
  upsertScore(where: ScoreWhereUniqueInput!, create: ScoreCreateInput!, update: ScoreUpdateInput!): Score!
  deleteScore(where: ScoreWhereUniqueInput!): Score
  deleteManyScores(where: ScoreWhereInput): BatchPayload!
  createScoringFormatSetting(data: ScoringFormatSettingCreateInput!): ScoringFormatSetting!
  updateScoringFormatSetting(data: ScoringFormatSettingUpdateInput!, where: ScoringFormatSettingWhereUniqueInput!): ScoringFormatSetting
  updateManyScoringFormatSettings(data: ScoringFormatSettingUpdateManyMutationInput!, where: ScoringFormatSettingWhereInput): BatchPayload!
  upsertScoringFormatSetting(where: ScoringFormatSettingWhereUniqueInput!, create: ScoringFormatSettingCreateInput!, update: ScoringFormatSettingUpdateInput!): ScoringFormatSetting!
  deleteScoringFormatSetting(where: ScoringFormatSettingWhereUniqueInput!): ScoringFormatSetting
  deleteManyScoringFormatSettings(where: ScoringFormatSettingWhereInput): BatchPayload!
  createSector(data: SectorCreateInput!): Sector!
  updateSector(data: SectorUpdateInput!, where: SectorWhereUniqueInput!): Sector
  updateManySectors(data: SectorUpdateManyMutationInput!, where: SectorWhereInput): BatchPayload!
  upsertSector(where: SectorWhereUniqueInput!, create: SectorCreateInput!, update: SectorUpdateInput!): Sector!
  deleteSector(where: SectorWhereUniqueInput!): Sector
  deleteManySectors(where: SectorWhereInput): BatchPayload!
  createSystemSubscription(data: SystemSubscriptionCreateInput!): SystemSubscription!
  updateSystemSubscription(data: SystemSubscriptionUpdateInput!, where: SystemSubscriptionWhereUniqueInput!): SystemSubscription
  updateManySystemSubscriptions(data: SystemSubscriptionUpdateManyMutationInput!, where: SystemSubscriptionWhereInput): BatchPayload!
  upsertSystemSubscription(where: SystemSubscriptionWhereUniqueInput!, create: SystemSubscriptionCreateInput!, update: SystemSubscriptionUpdateInput!): SystemSubscription!
  deleteSystemSubscription(where: SystemSubscriptionWhereUniqueInput!): SystemSubscription
  deleteManySystemSubscriptions(where: SystemSubscriptionWhereInput): BatchPayload!
  createSystemSubscriptionPlan(data: SystemSubscriptionPlanCreateInput!): SystemSubscriptionPlan!
  updateSystemSubscriptionPlan(data: SystemSubscriptionPlanUpdateInput!, where: SystemSubscriptionPlanWhereUniqueInput!): SystemSubscriptionPlan
  updateManySystemSubscriptionPlans(data: SystemSubscriptionPlanUpdateManyMutationInput!, where: SystemSubscriptionPlanWhereInput): BatchPayload!
  upsertSystemSubscriptionPlan(where: SystemSubscriptionPlanWhereUniqueInput!, create: SystemSubscriptionPlanCreateInput!, update: SystemSubscriptionPlanUpdateInput!): SystemSubscriptionPlan!
  deleteSystemSubscriptionPlan(where: SystemSubscriptionPlanWhereUniqueInput!): SystemSubscriptionPlan
  deleteManySystemSubscriptionPlans(where: SystemSubscriptionPlanWhereInput): BatchPayload!
  createTimezone(data: TimezoneCreateInput!): Timezone!
  updateTimezone(data: TimezoneUpdateInput!, where: TimezoneWhereUniqueInput!): Timezone
  updateManyTimezones(data: TimezoneUpdateManyMutationInput!, where: TimezoneWhereInput): BatchPayload!
  upsertTimezone(where: TimezoneWhereUniqueInput!, create: TimezoneCreateInput!, update: TimezoneUpdateInput!): Timezone!
  deleteTimezone(where: TimezoneWhereUniqueInput!): Timezone
  deleteManyTimezones(where: TimezoneWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createWorkflow(data: WorkflowCreateInput!): Workflow!
  updateWorkflow(data: WorkflowUpdateInput!, where: WorkflowWhereUniqueInput!): Workflow
  updateManyWorkflows(data: WorkflowUpdateManyMutationInput!, where: WorkflowWhereInput): BatchPayload!
  upsertWorkflow(where: WorkflowWhereUniqueInput!, create: WorkflowCreateInput!, update: WorkflowUpdateInput!): Workflow!
  deleteWorkflow(where: WorkflowWhereUniqueInput!): Workflow
  deleteManyWorkflows(where: WorkflowWhereInput): BatchPayload!
  createWorkflowApplication(data: WorkflowApplicationCreateInput!): WorkflowApplication!
  updateWorkflowApplication(data: WorkflowApplicationUpdateInput!, where: WorkflowApplicationWhereUniqueInput!): WorkflowApplication
  updateManyWorkflowApplications(data: WorkflowApplicationUpdateManyMutationInput!, where: WorkflowApplicationWhereInput): BatchPayload!
  upsertWorkflowApplication(where: WorkflowApplicationWhereUniqueInput!, create: WorkflowApplicationCreateInput!, update: WorkflowApplicationUpdateInput!): WorkflowApplication!
  deleteWorkflowApplication(where: WorkflowApplicationWhereUniqueInput!): WorkflowApplication
  deleteManyWorkflowApplications(where: WorkflowApplicationWhereInput): BatchPayload!
  createWorkflowJudge(data: WorkflowJudgeCreateInput!): WorkflowJudge!
  updateWorkflowJudge(data: WorkflowJudgeUpdateInput!, where: WorkflowJudgeWhereUniqueInput!): WorkflowJudge
  updateManyWorkflowJudges(data: WorkflowJudgeUpdateManyMutationInput!, where: WorkflowJudgeWhereInput): BatchPayload!
  upsertWorkflowJudge(where: WorkflowJudgeWhereUniqueInput!, create: WorkflowJudgeCreateInput!, update: WorkflowJudgeUpdateInput!): WorkflowJudge!
  deleteWorkflowJudge(where: WorkflowJudgeWhereUniqueInput!): WorkflowJudge
  deleteManyWorkflowJudges(where: WorkflowJudgeWhereInput): BatchPayload!
  createWorkflowSubscription(data: WorkflowSubscriptionCreateInput!): WorkflowSubscription!
  updateWorkflowSubscription(data: WorkflowSubscriptionUpdateInput!, where: WorkflowSubscriptionWhereUniqueInput!): WorkflowSubscription
  updateManyWorkflowSubscriptions(data: WorkflowSubscriptionUpdateManyMutationInput!, where: WorkflowSubscriptionWhereInput): BatchPayload!
  upsertWorkflowSubscription(where: WorkflowSubscriptionWhereUniqueInput!, create: WorkflowSubscriptionCreateInput!, update: WorkflowSubscriptionUpdateInput!): WorkflowSubscription!
  deleteWorkflowSubscription(where: WorkflowSubscriptionWhereUniqueInput!): WorkflowSubscription
  deleteManyWorkflowSubscriptions(where: WorkflowSubscriptionWhereInput): BatchPayload!
  createWorkflowSubscriptionPlan(data: WorkflowSubscriptionPlanCreateInput!): WorkflowSubscriptionPlan!
  updateWorkflowSubscriptionPlan(data: WorkflowSubscriptionPlanUpdateInput!, where: WorkflowSubscriptionPlanWhereUniqueInput!): WorkflowSubscriptionPlan
  updateManyWorkflowSubscriptionPlans(data: WorkflowSubscriptionPlanUpdateManyMutationInput!, where: WorkflowSubscriptionPlanWhereInput): BatchPayload!
  upsertWorkflowSubscriptionPlan(where: WorkflowSubscriptionPlanWhereUniqueInput!, create: WorkflowSubscriptionPlanCreateInput!, update: WorkflowSubscriptionPlanUpdateInput!): WorkflowSubscriptionPlan!
  deleteWorkflowSubscriptionPlan(where: WorkflowSubscriptionPlanWhereUniqueInput!): WorkflowSubscriptionPlan
  deleteManyWorkflowSubscriptionPlans(where: WorkflowSubscriptionPlanWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Organization {
  id: ID!
  name: String!
  email: String!
  phone: String!
  sectors(where: SectorWhereInput, orderBy: SectorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sector!]
  country: Country!
  city: City!
  bio: String!
  staff(where: OrganizationStaffWhereInput, orderBy: OrganizationStaffOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrganizationStaff!]
  workflows(where: WorkflowWhereInput, orderBy: WorkflowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workflow!]
  cover: File!
  logo: File!
  createdAt: DateTime
  updatedAt: DateTime
}

type OrganizationConnection {
  pageInfo: PageInfo!
  edges: [OrganizationEdge]!
  aggregate: AggregateOrganization!
}

input OrganizationCreateInput {
  id: ID
  name: String!
  email: String!
  phone: String!
  sectors: SectorCreateManyInput
  country: CountryCreateOneInput!
  city: CityCreateOneInput!
  bio: String!
  staff: OrganizationStaffCreateManyWithoutOrganizationInput
  workflows: WorkflowCreateManyWithoutOrganizationInput
  cover: FileCreateOneInput!
  logo: FileCreateOneInput!
}

input OrganizationCreateManyInput {
  create: [OrganizationCreateInput!]
  connect: [OrganizationWhereUniqueInput!]
}

input OrganizationCreateOneInput {
  create: OrganizationCreateInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationCreateOneWithoutStaffInput {
  create: OrganizationCreateWithoutStaffInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationCreateOneWithoutWorkflowsInput {
  create: OrganizationCreateWithoutWorkflowsInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationCreateWithoutStaffInput {
  id: ID
  name: String!
  email: String!
  phone: String!
  sectors: SectorCreateManyInput
  country: CountryCreateOneInput!
  city: CityCreateOneInput!
  bio: String!
  workflows: WorkflowCreateManyWithoutOrganizationInput
  cover: FileCreateOneInput!
  logo: FileCreateOneInput!
}

input OrganizationCreateWithoutWorkflowsInput {
  id: ID
  name: String!
  email: String!
  phone: String!
  sectors: SectorCreateManyInput
  country: CountryCreateOneInput!
  city: CityCreateOneInput!
  bio: String!
  staff: OrganizationStaffCreateManyWithoutOrganizationInput
  cover: FileCreateOneInput!
  logo: FileCreateOneInput!
}

type OrganizationEdge {
  node: Organization!
  cursor: String!
}

enum OrganizationOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  bio_ASC
  bio_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OrganizationPreviousValues {
  id: ID!
  name: String!
  email: String!
  phone: String!
  bio: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input OrganizationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrganizationScalarWhereInput!]
  OR: [OrganizationScalarWhereInput!]
  NOT: [OrganizationScalarWhereInput!]
}

type OrganizationStaff {
  id: ID!
  user: User!
  organization: Organization!
  status: ProcessState!
  role: Role!
  createdAt: DateTime
  updatedAt: DateTime
}

type OrganizationStaffConnection {
  pageInfo: PageInfo!
  edges: [OrganizationStaffEdge]!
  aggregate: AggregateOrganizationStaff!
}

input OrganizationStaffCreateInput {
  id: ID
  user: UserCreateOneWithoutStaffOfInput!
  organization: OrganizationCreateOneWithoutStaffInput!
  status: ProcessState!
  role: Role
}

input OrganizationStaffCreateManyWithoutOrganizationInput {
  create: [OrganizationStaffCreateWithoutOrganizationInput!]
  connect: [OrganizationStaffWhereUniqueInput!]
}

input OrganizationStaffCreateManyWithoutUserInput {
  create: [OrganizationStaffCreateWithoutUserInput!]
  connect: [OrganizationStaffWhereUniqueInput!]
}

input OrganizationStaffCreateWithoutOrganizationInput {
  id: ID
  user: UserCreateOneWithoutStaffOfInput!
  status: ProcessState!
  role: Role
}

input OrganizationStaffCreateWithoutUserInput {
  id: ID
  organization: OrganizationCreateOneWithoutStaffInput!
  status: ProcessState!
  role: Role
}

type OrganizationStaffEdge {
  node: OrganizationStaff!
  cursor: String!
}

enum OrganizationStaffOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  role_ASC
  role_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OrganizationStaffPreviousValues {
  id: ID!
  status: ProcessState!
  role: Role!
  createdAt: DateTime
  updatedAt: DateTime
}

input OrganizationStaffScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrganizationStaffScalarWhereInput!]
  OR: [OrganizationStaffScalarWhereInput!]
  NOT: [OrganizationStaffScalarWhereInput!]
}

type OrganizationStaffSubscriptionPayload {
  mutation: MutationType!
  node: OrganizationStaff
  updatedFields: [String!]
  previousValues: OrganizationStaffPreviousValues
}

input OrganizationStaffSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrganizationStaffWhereInput
  AND: [OrganizationStaffSubscriptionWhereInput!]
  OR: [OrganizationStaffSubscriptionWhereInput!]
  NOT: [OrganizationStaffSubscriptionWhereInput!]
}

input OrganizationStaffUpdateInput {
  user: UserUpdateOneRequiredWithoutStaffOfInput
  organization: OrganizationUpdateOneRequiredWithoutStaffInput
  status: ProcessState
  role: Role
}

input OrganizationStaffUpdateManyDataInput {
  status: ProcessState
  role: Role
}

input OrganizationStaffUpdateManyMutationInput {
  status: ProcessState
  role: Role
}

input OrganizationStaffUpdateManyWithoutOrganizationInput {
  create: [OrganizationStaffCreateWithoutOrganizationInput!]
  delete: [OrganizationStaffWhereUniqueInput!]
  connect: [OrganizationStaffWhereUniqueInput!]
  set: [OrganizationStaffWhereUniqueInput!]
  disconnect: [OrganizationStaffWhereUniqueInput!]
  update: [OrganizationStaffUpdateWithWhereUniqueWithoutOrganizationInput!]
  upsert: [OrganizationStaffUpsertWithWhereUniqueWithoutOrganizationInput!]
  deleteMany: [OrganizationStaffScalarWhereInput!]
  updateMany: [OrganizationStaffUpdateManyWithWhereNestedInput!]
}

input OrganizationStaffUpdateManyWithoutUserInput {
  create: [OrganizationStaffCreateWithoutUserInput!]
  delete: [OrganizationStaffWhereUniqueInput!]
  connect: [OrganizationStaffWhereUniqueInput!]
  set: [OrganizationStaffWhereUniqueInput!]
  disconnect: [OrganizationStaffWhereUniqueInput!]
  update: [OrganizationStaffUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [OrganizationStaffUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [OrganizationStaffScalarWhereInput!]
  updateMany: [OrganizationStaffUpdateManyWithWhereNestedInput!]
}

input OrganizationStaffUpdateManyWithWhereNestedInput {
  where: OrganizationStaffScalarWhereInput!
  data: OrganizationStaffUpdateManyDataInput!
}

input OrganizationStaffUpdateWithoutOrganizationDataInput {
  user: UserUpdateOneRequiredWithoutStaffOfInput
  status: ProcessState
  role: Role
}

input OrganizationStaffUpdateWithoutUserDataInput {
  organization: OrganizationUpdateOneRequiredWithoutStaffInput
  status: ProcessState
  role: Role
}

input OrganizationStaffUpdateWithWhereUniqueWithoutOrganizationInput {
  where: OrganizationStaffWhereUniqueInput!
  data: OrganizationStaffUpdateWithoutOrganizationDataInput!
}

input OrganizationStaffUpdateWithWhereUniqueWithoutUserInput {
  where: OrganizationStaffWhereUniqueInput!
  data: OrganizationStaffUpdateWithoutUserDataInput!
}

input OrganizationStaffUpsertWithWhereUniqueWithoutOrganizationInput {
  where: OrganizationStaffWhereUniqueInput!
  update: OrganizationStaffUpdateWithoutOrganizationDataInput!
  create: OrganizationStaffCreateWithoutOrganizationInput!
}

input OrganizationStaffUpsertWithWhereUniqueWithoutUserInput {
  where: OrganizationStaffWhereUniqueInput!
  update: OrganizationStaffUpdateWithoutUserDataInput!
  create: OrganizationStaffCreateWithoutUserInput!
}

input OrganizationStaffWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  organization: OrganizationWhereInput
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  role: Role
  role_not: Role
  role_in: [Role!]
  role_not_in: [Role!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrganizationStaffWhereInput!]
  OR: [OrganizationStaffWhereInput!]
  NOT: [OrganizationStaffWhereInput!]
}

input OrganizationStaffWhereUniqueInput {
  id: ID
}

type OrganizationSubscriptionPayload {
  mutation: MutationType!
  node: Organization
  updatedFields: [String!]
  previousValues: OrganizationPreviousValues
}

input OrganizationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrganizationWhereInput
  AND: [OrganizationSubscriptionWhereInput!]
  OR: [OrganizationSubscriptionWhereInput!]
  NOT: [OrganizationSubscriptionWhereInput!]
}

input OrganizationUpdateDataInput {
  name: String
  email: String
  phone: String
  sectors: SectorUpdateManyInput
  country: CountryUpdateOneRequiredInput
  city: CityUpdateOneRequiredInput
  bio: String
  staff: OrganizationStaffUpdateManyWithoutOrganizationInput
  workflows: WorkflowUpdateManyWithoutOrganizationInput
  cover: FileUpdateOneRequiredInput
  logo: FileUpdateOneRequiredInput
}

input OrganizationUpdateInput {
  name: String
  email: String
  phone: String
  sectors: SectorUpdateManyInput
  country: CountryUpdateOneRequiredInput
  city: CityUpdateOneRequiredInput
  bio: String
  staff: OrganizationStaffUpdateManyWithoutOrganizationInput
  workflows: WorkflowUpdateManyWithoutOrganizationInput
  cover: FileUpdateOneRequiredInput
  logo: FileUpdateOneRequiredInput
}

input OrganizationUpdateManyDataInput {
  name: String
  email: String
  phone: String
  bio: String
}

input OrganizationUpdateManyInput {
  create: [OrganizationCreateInput!]
  update: [OrganizationUpdateWithWhereUniqueNestedInput!]
  upsert: [OrganizationUpsertWithWhereUniqueNestedInput!]
  delete: [OrganizationWhereUniqueInput!]
  connect: [OrganizationWhereUniqueInput!]
  set: [OrganizationWhereUniqueInput!]
  disconnect: [OrganizationWhereUniqueInput!]
  deleteMany: [OrganizationScalarWhereInput!]
  updateMany: [OrganizationUpdateManyWithWhereNestedInput!]
}

input OrganizationUpdateManyMutationInput {
  name: String
  email: String
  phone: String
  bio: String
}

input OrganizationUpdateManyWithWhereNestedInput {
  where: OrganizationScalarWhereInput!
  data: OrganizationUpdateManyDataInput!
}

input OrganizationUpdateOneRequiredInput {
  create: OrganizationCreateInput
  update: OrganizationUpdateDataInput
  upsert: OrganizationUpsertNestedInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationUpdateOneRequiredWithoutStaffInput {
  create: OrganizationCreateWithoutStaffInput
  update: OrganizationUpdateWithoutStaffDataInput
  upsert: OrganizationUpsertWithoutStaffInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationUpdateOneRequiredWithoutWorkflowsInput {
  create: OrganizationCreateWithoutWorkflowsInput
  update: OrganizationUpdateWithoutWorkflowsDataInput
  upsert: OrganizationUpsertWithoutWorkflowsInput
  connect: OrganizationWhereUniqueInput
}

input OrganizationUpdateWithoutStaffDataInput {
  name: String
  email: String
  phone: String
  sectors: SectorUpdateManyInput
  country: CountryUpdateOneRequiredInput
  city: CityUpdateOneRequiredInput
  bio: String
  workflows: WorkflowUpdateManyWithoutOrganizationInput
  cover: FileUpdateOneRequiredInput
  logo: FileUpdateOneRequiredInput
}

input OrganizationUpdateWithoutWorkflowsDataInput {
  name: String
  email: String
  phone: String
  sectors: SectorUpdateManyInput
  country: CountryUpdateOneRequiredInput
  city: CityUpdateOneRequiredInput
  bio: String
  staff: OrganizationStaffUpdateManyWithoutOrganizationInput
  cover: FileUpdateOneRequiredInput
  logo: FileUpdateOneRequiredInput
}

input OrganizationUpdateWithWhereUniqueNestedInput {
  where: OrganizationWhereUniqueInput!
  data: OrganizationUpdateDataInput!
}

input OrganizationUpsertNestedInput {
  update: OrganizationUpdateDataInput!
  create: OrganizationCreateInput!
}

input OrganizationUpsertWithoutStaffInput {
  update: OrganizationUpdateWithoutStaffDataInput!
  create: OrganizationCreateWithoutStaffInput!
}

input OrganizationUpsertWithoutWorkflowsInput {
  update: OrganizationUpdateWithoutWorkflowsDataInput!
  create: OrganizationCreateWithoutWorkflowsInput!
}

input OrganizationUpsertWithWhereUniqueNestedInput {
  where: OrganizationWhereUniqueInput!
  update: OrganizationUpdateDataInput!
  create: OrganizationCreateInput!
}

input OrganizationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  sectors_every: SectorWhereInput
  sectors_some: SectorWhereInput
  sectors_none: SectorWhereInput
  country: CountryWhereInput
  city: CityWhereInput
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  staff_every: OrganizationStaffWhereInput
  staff_some: OrganizationStaffWhereInput
  staff_none: OrganizationStaffWhereInput
  workflows_every: WorkflowWhereInput
  workflows_some: WorkflowWhereInput
  workflows_none: WorkflowWhereInput
  cover: FileWhereInput
  logo: FileWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrganizationWhereInput!]
  OR: [OrganizationWhereInput!]
  NOT: [OrganizationWhereInput!]
}

input OrganizationWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type PaymentMethod {
  id: ID!
  name: String!
}

type PaymentMethodConnection {
  pageInfo: PageInfo!
  edges: [PaymentMethodEdge]!
  aggregate: AggregatePaymentMethod!
}

input PaymentMethodCreateInput {
  id: ID
  name: String!
}

input PaymentMethodCreateManyInput {
  create: [PaymentMethodCreateInput!]
  connect: [PaymentMethodWhereUniqueInput!]
}

type PaymentMethodEdge {
  node: PaymentMethod!
  cursor: String!
}

enum PaymentMethodOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type PaymentMethodPreviousValues {
  id: ID!
  name: String!
}

input PaymentMethodScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [PaymentMethodScalarWhereInput!]
  OR: [PaymentMethodScalarWhereInput!]
  NOT: [PaymentMethodScalarWhereInput!]
}

type PaymentMethodSubscriptionPayload {
  mutation: MutationType!
  node: PaymentMethod
  updatedFields: [String!]
  previousValues: PaymentMethodPreviousValues
}

input PaymentMethodSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentMethodWhereInput
  AND: [PaymentMethodSubscriptionWhereInput!]
  OR: [PaymentMethodSubscriptionWhereInput!]
  NOT: [PaymentMethodSubscriptionWhereInput!]
}

input PaymentMethodUpdateDataInput {
  name: String
}

input PaymentMethodUpdateInput {
  name: String
}

input PaymentMethodUpdateManyDataInput {
  name: String
}

input PaymentMethodUpdateManyInput {
  create: [PaymentMethodCreateInput!]
  update: [PaymentMethodUpdateWithWhereUniqueNestedInput!]
  upsert: [PaymentMethodUpsertWithWhereUniqueNestedInput!]
  delete: [PaymentMethodWhereUniqueInput!]
  connect: [PaymentMethodWhereUniqueInput!]
  set: [PaymentMethodWhereUniqueInput!]
  disconnect: [PaymentMethodWhereUniqueInput!]
  deleteMany: [PaymentMethodScalarWhereInput!]
  updateMany: [PaymentMethodUpdateManyWithWhereNestedInput!]
}

input PaymentMethodUpdateManyMutationInput {
  name: String
}

input PaymentMethodUpdateManyWithWhereNestedInput {
  where: PaymentMethodScalarWhereInput!
  data: PaymentMethodUpdateManyDataInput!
}

input PaymentMethodUpdateWithWhereUniqueNestedInput {
  where: PaymentMethodWhereUniqueInput!
  data: PaymentMethodUpdateDataInput!
}

input PaymentMethodUpsertWithWhereUniqueNestedInput {
  where: PaymentMethodWhereUniqueInput!
  update: PaymentMethodUpdateDataInput!
  create: PaymentMethodCreateInput!
}

input PaymentMethodWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [PaymentMethodWhereInput!]
  OR: [PaymentMethodWhereInput!]
  NOT: [PaymentMethodWhereInput!]
}

input PaymentMethodWhereUniqueInput {
  id: ID
  name: String
}

enum ProcessState {
  PENDING
  REVIEW
  REJECTED
  APPROVED
}

type Query {
  admin(where: AdminWhereUniqueInput!): Admin
  admins(where: AdminWhereInput, orderBy: AdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Admin]!
  adminsConnection(where: AdminWhereInput, orderBy: AdminOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AdminConnection!
  answer(where: AnswerWhereUniqueInput!): Answer
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer]!
  answersConnection(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AnswerConnection!
  changePasswordRequest(where: ChangePasswordRequestWhereUniqueInput!): ChangePasswordRequest
  changePasswordRequests(where: ChangePasswordRequestWhereInput, orderBy: ChangePasswordRequestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ChangePasswordRequest]!
  changePasswordRequestsConnection(where: ChangePasswordRequestWhereInput, orderBy: ChangePasswordRequestOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChangePasswordRequestConnection!
  city(where: CityWhereUniqueInput!): City
  cities(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [City]!
  citiesConnection(where: CityWhereInput, orderBy: CityOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CityConnection!
  country(where: CountryWhereUniqueInput!): Country
  countries(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Country]!
  countriesConnection(where: CountryWhereInput, orderBy: CountryOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CountryConnection!
  currency(where: CurrencyWhereUniqueInput!): Currency
  currencies(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Currency]!
  currenciesConnection(where: CurrencyWhereInput, orderBy: CurrencyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CurrencyConnection!
  expertise(where: ExpertiseWhereUniqueInput!): Expertise
  expertises(where: ExpertiseWhereInput, orderBy: ExpertiseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Expertise]!
  expertisesConnection(where: ExpertiseWhereInput, orderBy: ExpertiseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExpertiseConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  form(where: FormWhereUniqueInput!): Form
  forms(where: FormWhereInput, orderBy: FormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Form]!
  formsConnection(where: FormWhereInput, orderBy: FormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FormConnection!
  formResponse(where: FormResponseWhereUniqueInput!): FormResponse
  formResponses(where: FormResponseWhereInput, orderBy: FormResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FormResponse]!
  formResponsesConnection(where: FormResponseWhereInput, orderBy: FormResponseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FormResponseConnection!
  formScore(where: FormScoreWhereUniqueInput!): FormScore
  formScores(where: FormScoreWhereInput, orderBy: FormScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [FormScore]!
  formScoresConnection(where: FormScoreWhereInput, orderBy: FormScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FormScoreConnection!
  invitation(where: InvitationWhereUniqueInput!): Invitation
  invitations(where: InvitationWhereInput, orderBy: InvitationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invitation]!
  invitationsConnection(where: InvitationWhereInput, orderBy: InvitationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): InvitationConnection!
  organization(where: OrganizationWhereUniqueInput!): Organization
  organizations(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Organization]!
  organizationsConnection(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrganizationConnection!
  organizationStaff(where: OrganizationStaffWhereUniqueInput!): OrganizationStaff
  organizationStaffs(where: OrganizationStaffWhereInput, orderBy: OrganizationStaffOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrganizationStaff]!
  organizationStaffsConnection(where: OrganizationStaffWhereInput, orderBy: OrganizationStaffOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrganizationStaffConnection!
  paymentMethod(where: PaymentMethodWhereUniqueInput!): PaymentMethod
  paymentMethods(where: PaymentMethodWhereInput, orderBy: PaymentMethodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentMethod]!
  paymentMethodsConnection(where: PaymentMethodWhereInput, orderBy: PaymentMethodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentMethodConnection!
  question(where: QuestionWhereUniqueInput!): Question
  questions(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Question]!
  questionsConnection(where: QuestionWhereInput, orderBy: QuestionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): QuestionConnection!
  score(where: ScoreWhereUniqueInput!): Score
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score]!
  scoresConnection(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoreConnection!
  scoringFormatSetting(where: ScoringFormatSettingWhereUniqueInput!): ScoringFormatSetting
  scoringFormatSettings(where: ScoringFormatSettingWhereInput, orderBy: ScoringFormatSettingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ScoringFormatSetting]!
  scoringFormatSettingsConnection(where: ScoringFormatSettingWhereInput, orderBy: ScoringFormatSettingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoringFormatSettingConnection!
  sector(where: SectorWhereUniqueInput!): Sector
  sectors(where: SectorWhereInput, orderBy: SectorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Sector]!
  sectorsConnection(where: SectorWhereInput, orderBy: SectorOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SectorConnection!
  systemSubscription(where: SystemSubscriptionWhereUniqueInput!): SystemSubscription
  systemSubscriptions(where: SystemSubscriptionWhereInput, orderBy: SystemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SystemSubscription]!
  systemSubscriptionsConnection(where: SystemSubscriptionWhereInput, orderBy: SystemSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SystemSubscriptionConnection!
  systemSubscriptionPlan(where: SystemSubscriptionPlanWhereUniqueInput!): SystemSubscriptionPlan
  systemSubscriptionPlans(where: SystemSubscriptionPlanWhereInput, orderBy: SystemSubscriptionPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SystemSubscriptionPlan]!
  systemSubscriptionPlansConnection(where: SystemSubscriptionPlanWhereInput, orderBy: SystemSubscriptionPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SystemSubscriptionPlanConnection!
  timezone(where: TimezoneWhereUniqueInput!): Timezone
  timezones(where: TimezoneWhereInput, orderBy: TimezoneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Timezone]!
  timezonesConnection(where: TimezoneWhereInput, orderBy: TimezoneOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TimezoneConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  workflow(where: WorkflowWhereUniqueInput!): Workflow
  workflows(where: WorkflowWhereInput, orderBy: WorkflowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Workflow]!
  workflowsConnection(where: WorkflowWhereInput, orderBy: WorkflowOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkflowConnection!
  workflowApplication(where: WorkflowApplicationWhereUniqueInput!): WorkflowApplication
  workflowApplications(where: WorkflowApplicationWhereInput, orderBy: WorkflowApplicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkflowApplication]!
  workflowApplicationsConnection(where: WorkflowApplicationWhereInput, orderBy: WorkflowApplicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkflowApplicationConnection!
  workflowJudge(where: WorkflowJudgeWhereUniqueInput!): WorkflowJudge
  workflowJudges(where: WorkflowJudgeWhereInput, orderBy: WorkflowJudgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkflowJudge]!
  workflowJudgesConnection(where: WorkflowJudgeWhereInput, orderBy: WorkflowJudgeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkflowJudgeConnection!
  workflowSubscription(where: WorkflowSubscriptionWhereUniqueInput!): WorkflowSubscription
  workflowSubscriptions(where: WorkflowSubscriptionWhereInput, orderBy: WorkflowSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkflowSubscription]!
  workflowSubscriptionsConnection(where: WorkflowSubscriptionWhereInput, orderBy: WorkflowSubscriptionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkflowSubscriptionConnection!
  workflowSubscriptionPlan(where: WorkflowSubscriptionPlanWhereUniqueInput!): WorkflowSubscriptionPlan
  workflowSubscriptionPlans(where: WorkflowSubscriptionPlanWhereInput, orderBy: WorkflowSubscriptionPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkflowSubscriptionPlan]!
  workflowSubscriptionPlansConnection(where: WorkflowSubscriptionPlanWhereInput, orderBy: WorkflowSubscriptionPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): WorkflowSubscriptionPlanConnection!
  node(id: ID!): Node
}

type Question {
  id: ID!
  question: String!
  questionNumber: Int!
  scoringFormat: ScoringFormat
  scoringFormatSettings: ScoringFormatSetting
  options: [String!]!
  questionType: QuestionType
  form: Form!
  answers(where: AnswerWhereInput, orderBy: AnswerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Answer!]
  createdAt: DateTime
  updatedAt: DateTime
}

type QuestionConnection {
  pageInfo: PageInfo!
  edges: [QuestionEdge]!
  aggregate: AggregateQuestion!
}

input QuestionCreateInput {
  id: ID
  question: String!
  questionNumber: Int!
  scoringFormat: ScoringFormat
  scoringFormatSettings: ScoringFormatSettingCreateOneInput
  options: QuestionCreateoptionsInput
  questionType: QuestionType
  form: FormCreateOneWithoutQuestionsInput!
  answers: AnswerCreateManyWithoutQuestionInput
}

input QuestionCreateManyWithoutFormInput {
  create: [QuestionCreateWithoutFormInput!]
  connect: [QuestionWhereUniqueInput!]
}

input QuestionCreateOneWithoutAnswersInput {
  create: QuestionCreateWithoutAnswersInput
  connect: QuestionWhereUniqueInput
}

input QuestionCreateoptionsInput {
  set: [String!]
}

input QuestionCreateWithoutAnswersInput {
  id: ID
  question: String!
  questionNumber: Int!
  scoringFormat: ScoringFormat
  scoringFormatSettings: ScoringFormatSettingCreateOneInput
  options: QuestionCreateoptionsInput
  questionType: QuestionType
  form: FormCreateOneWithoutQuestionsInput!
}

input QuestionCreateWithoutFormInput {
  id: ID
  question: String!
  questionNumber: Int!
  scoringFormat: ScoringFormat
  scoringFormatSettings: ScoringFormatSettingCreateOneInput
  options: QuestionCreateoptionsInput
  questionType: QuestionType
  answers: AnswerCreateManyWithoutQuestionInput
}

type QuestionEdge {
  node: Question!
  cursor: String!
}

enum QuestionOrderByInput {
  id_ASC
  id_DESC
  question_ASC
  question_DESC
  questionNumber_ASC
  questionNumber_DESC
  scoringFormat_ASC
  scoringFormat_DESC
  questionType_ASC
  questionType_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type QuestionPreviousValues {
  id: ID!
  question: String!
  questionNumber: Int!
  scoringFormat: ScoringFormat
  options: [String!]!
  questionType: QuestionType
  createdAt: DateTime
  updatedAt: DateTime
}

input QuestionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  question: String
  question_not: String
  question_in: [String!]
  question_not_in: [String!]
  question_lt: String
  question_lte: String
  question_gt: String
  question_gte: String
  question_contains: String
  question_not_contains: String
  question_starts_with: String
  question_not_starts_with: String
  question_ends_with: String
  question_not_ends_with: String
  questionNumber: Int
  questionNumber_not: Int
  questionNumber_in: [Int!]
  questionNumber_not_in: [Int!]
  questionNumber_lt: Int
  questionNumber_lte: Int
  questionNumber_gt: Int
  questionNumber_gte: Int
  scoringFormat: ScoringFormat
  scoringFormat_not: ScoringFormat
  scoringFormat_in: [ScoringFormat!]
  scoringFormat_not_in: [ScoringFormat!]
  questionType: QuestionType
  questionType_not: QuestionType
  questionType_in: [QuestionType!]
  questionType_not_in: [QuestionType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
}

type QuestionSubscriptionPayload {
  mutation: MutationType!
  node: Question
  updatedFields: [String!]
  previousValues: QuestionPreviousValues
}

input QuestionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: QuestionWhereInput
  AND: [QuestionSubscriptionWhereInput!]
  OR: [QuestionSubscriptionWhereInput!]
  NOT: [QuestionSubscriptionWhereInput!]
}

enum QuestionType {
  Text
  MultipleChoice
  Boolean
  Email
  Date
  Number
  Dropdown
  File
  MultipleSelection
  TextArea
}

input QuestionUpdateInput {
  question: String
  questionNumber: Int
  scoringFormat: ScoringFormat
  scoringFormatSettings: ScoringFormatSettingUpdateOneInput
  options: QuestionUpdateoptionsInput
  questionType: QuestionType
  form: FormUpdateOneRequiredWithoutQuestionsInput
  answers: AnswerUpdateManyWithoutQuestionInput
}

input QuestionUpdateManyDataInput {
  question: String
  questionNumber: Int
  scoringFormat: ScoringFormat
  options: QuestionUpdateoptionsInput
  questionType: QuestionType
}

input QuestionUpdateManyMutationInput {
  question: String
  questionNumber: Int
  scoringFormat: ScoringFormat
  options: QuestionUpdateoptionsInput
  questionType: QuestionType
}

input QuestionUpdateManyWithoutFormInput {
  create: [QuestionCreateWithoutFormInput!]
  delete: [QuestionWhereUniqueInput!]
  connect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  disconnect: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutFormInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutFormInput!]
  deleteMany: [QuestionScalarWhereInput!]
  updateMany: [QuestionUpdateManyWithWhereNestedInput!]
}

input QuestionUpdateManyWithWhereNestedInput {
  where: QuestionScalarWhereInput!
  data: QuestionUpdateManyDataInput!
}

input QuestionUpdateOneRequiredWithoutAnswersInput {
  create: QuestionCreateWithoutAnswersInput
  update: QuestionUpdateWithoutAnswersDataInput
  upsert: QuestionUpsertWithoutAnswersInput
  connect: QuestionWhereUniqueInput
}

input QuestionUpdateoptionsInput {
  set: [String!]
}

input QuestionUpdateWithoutAnswersDataInput {
  question: String
  questionNumber: Int
  scoringFormat: ScoringFormat
  scoringFormatSettings: ScoringFormatSettingUpdateOneInput
  options: QuestionUpdateoptionsInput
  questionType: QuestionType
  form: FormUpdateOneRequiredWithoutQuestionsInput
}

input QuestionUpdateWithoutFormDataInput {
  question: String
  questionNumber: Int
  scoringFormat: ScoringFormat
  scoringFormatSettings: ScoringFormatSettingUpdateOneInput
  options: QuestionUpdateoptionsInput
  questionType: QuestionType
  answers: AnswerUpdateManyWithoutQuestionInput
}

input QuestionUpdateWithWhereUniqueWithoutFormInput {
  where: QuestionWhereUniqueInput!
  data: QuestionUpdateWithoutFormDataInput!
}

input QuestionUpsertWithoutAnswersInput {
  update: QuestionUpdateWithoutAnswersDataInput!
  create: QuestionCreateWithoutAnswersInput!
}

input QuestionUpsertWithWhereUniqueWithoutFormInput {
  where: QuestionWhereUniqueInput!
  update: QuestionUpdateWithoutFormDataInput!
  create: QuestionCreateWithoutFormInput!
}

input QuestionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  question: String
  question_not: String
  question_in: [String!]
  question_not_in: [String!]
  question_lt: String
  question_lte: String
  question_gt: String
  question_gte: String
  question_contains: String
  question_not_contains: String
  question_starts_with: String
  question_not_starts_with: String
  question_ends_with: String
  question_not_ends_with: String
  questionNumber: Int
  questionNumber_not: Int
  questionNumber_in: [Int!]
  questionNumber_not_in: [Int!]
  questionNumber_lt: Int
  questionNumber_lte: Int
  questionNumber_gt: Int
  questionNumber_gte: Int
  scoringFormat: ScoringFormat
  scoringFormat_not: ScoringFormat
  scoringFormat_in: [ScoringFormat!]
  scoringFormat_not_in: [ScoringFormat!]
  scoringFormatSettings: ScoringFormatSettingWhereInput
  questionType: QuestionType
  questionType_not: QuestionType
  questionType_in: [QuestionType!]
  questionType_not_in: [QuestionType!]
  form: FormWhereInput
  answers_every: AnswerWhereInput
  answers_some: AnswerWhereInput
  answers_none: AnswerWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
}

input QuestionWhereUniqueInput {
  id: ID
}

enum Role {
  OWNER
  ADMIN
  EDITOR
  SUBSCRIBER
}

type Score {
  id: ID!
  value: Int!
  answer: Answer!
}

type ScoreConnection {
  pageInfo: PageInfo!
  edges: [ScoreEdge]!
  aggregate: AggregateScore!
}

input ScoreCreateInput {
  id: ID
  value: Int!
  answer: AnswerCreateOneWithoutScoresInput!
}

input ScoreCreateManyInput {
  create: [ScoreCreateInput!]
  connect: [ScoreWhereUniqueInput!]
}

input ScoreCreateManyWithoutAnswerInput {
  create: [ScoreCreateWithoutAnswerInput!]
  connect: [ScoreWhereUniqueInput!]
}

input ScoreCreateWithoutAnswerInput {
  id: ID
  value: Int!
}

type ScoreEdge {
  node: Score!
  cursor: String!
}

enum ScoreOrderByInput {
  id_ASC
  id_DESC
  value_ASC
  value_DESC
}

type ScorePreviousValues {
  id: ID!
  value: Int!
}

input ScoreScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  AND: [ScoreScalarWhereInput!]
  OR: [ScoreScalarWhereInput!]
  NOT: [ScoreScalarWhereInput!]
}

type ScoreSubscriptionPayload {
  mutation: MutationType!
  node: Score
  updatedFields: [String!]
  previousValues: ScorePreviousValues
}

input ScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoreWhereInput
  AND: [ScoreSubscriptionWhereInput!]
  OR: [ScoreSubscriptionWhereInput!]
  NOT: [ScoreSubscriptionWhereInput!]
}

input ScoreUpdateDataInput {
  value: Int
  answer: AnswerUpdateOneRequiredWithoutScoresInput
}

input ScoreUpdateInput {
  value: Int
  answer: AnswerUpdateOneRequiredWithoutScoresInput
}

input ScoreUpdateManyDataInput {
  value: Int
}

input ScoreUpdateManyInput {
  create: [ScoreCreateInput!]
  update: [ScoreUpdateWithWhereUniqueNestedInput!]
  upsert: [ScoreUpsertWithWhereUniqueNestedInput!]
  delete: [ScoreWhereUniqueInput!]
  connect: [ScoreWhereUniqueInput!]
  set: [ScoreWhereUniqueInput!]
  disconnect: [ScoreWhereUniqueInput!]
  deleteMany: [ScoreScalarWhereInput!]
  updateMany: [ScoreUpdateManyWithWhereNestedInput!]
}

input ScoreUpdateManyMutationInput {
  value: Int
}

input ScoreUpdateManyWithoutAnswerInput {
  create: [ScoreCreateWithoutAnswerInput!]
  delete: [ScoreWhereUniqueInput!]
  connect: [ScoreWhereUniqueInput!]
  set: [ScoreWhereUniqueInput!]
  disconnect: [ScoreWhereUniqueInput!]
  update: [ScoreUpdateWithWhereUniqueWithoutAnswerInput!]
  upsert: [ScoreUpsertWithWhereUniqueWithoutAnswerInput!]
  deleteMany: [ScoreScalarWhereInput!]
  updateMany: [ScoreUpdateManyWithWhereNestedInput!]
}

input ScoreUpdateManyWithWhereNestedInput {
  where: ScoreScalarWhereInput!
  data: ScoreUpdateManyDataInput!
}

input ScoreUpdateWithoutAnswerDataInput {
  value: Int
}

input ScoreUpdateWithWhereUniqueNestedInput {
  where: ScoreWhereUniqueInput!
  data: ScoreUpdateDataInput!
}

input ScoreUpdateWithWhereUniqueWithoutAnswerInput {
  where: ScoreWhereUniqueInput!
  data: ScoreUpdateWithoutAnswerDataInput!
}

input ScoreUpsertWithWhereUniqueNestedInput {
  where: ScoreWhereUniqueInput!
  update: ScoreUpdateDataInput!
  create: ScoreCreateInput!
}

input ScoreUpsertWithWhereUniqueWithoutAnswerInput {
  where: ScoreWhereUniqueInput!
  update: ScoreUpdateWithoutAnswerDataInput!
  create: ScoreCreateWithoutAnswerInput!
}

input ScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  value: Int
  value_not: Int
  value_in: [Int!]
  value_not_in: [Int!]
  value_lt: Int
  value_lte: Int
  value_gt: Int
  value_gte: Int
  answer: AnswerWhereInput
  AND: [ScoreWhereInput!]
  OR: [ScoreWhereInput!]
  NOT: [ScoreWhereInput!]
}

input ScoreWhereUniqueInput {
  id: ID
}

enum ScoringFormat {
  Star
  Number
  Percent
}

type ScoringFormatSetting {
  id: ID!
  scoreRange: Int!
  stars: Int!
  labels: [String!]!
}

type ScoringFormatSettingConnection {
  pageInfo: PageInfo!
  edges: [ScoringFormatSettingEdge]!
  aggregate: AggregateScoringFormatSetting!
}

input ScoringFormatSettingCreateInput {
  id: ID
  scoreRange: Int!
  stars: Int!
  labels: ScoringFormatSettingCreatelabelsInput
}

input ScoringFormatSettingCreatelabelsInput {
  set: [String!]
}

input ScoringFormatSettingCreateOneInput {
  create: ScoringFormatSettingCreateInput
  connect: ScoringFormatSettingWhereUniqueInput
}

type ScoringFormatSettingEdge {
  node: ScoringFormatSetting!
  cursor: String!
}

enum ScoringFormatSettingOrderByInput {
  id_ASC
  id_DESC
  scoreRange_ASC
  scoreRange_DESC
  stars_ASC
  stars_DESC
}

type ScoringFormatSettingPreviousValues {
  id: ID!
  scoreRange: Int!
  stars: Int!
  labels: [String!]!
}

type ScoringFormatSettingSubscriptionPayload {
  mutation: MutationType!
  node: ScoringFormatSetting
  updatedFields: [String!]
  previousValues: ScoringFormatSettingPreviousValues
}

input ScoringFormatSettingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoringFormatSettingWhereInput
  AND: [ScoringFormatSettingSubscriptionWhereInput!]
  OR: [ScoringFormatSettingSubscriptionWhereInput!]
  NOT: [ScoringFormatSettingSubscriptionWhereInput!]
}

input ScoringFormatSettingUpdateDataInput {
  scoreRange: Int
  stars: Int
  labels: ScoringFormatSettingUpdatelabelsInput
}

input ScoringFormatSettingUpdateInput {
  scoreRange: Int
  stars: Int
  labels: ScoringFormatSettingUpdatelabelsInput
}

input ScoringFormatSettingUpdatelabelsInput {
  set: [String!]
}

input ScoringFormatSettingUpdateManyMutationInput {
  scoreRange: Int
  stars: Int
  labels: ScoringFormatSettingUpdatelabelsInput
}

input ScoringFormatSettingUpdateOneInput {
  create: ScoringFormatSettingCreateInput
  update: ScoringFormatSettingUpdateDataInput
  upsert: ScoringFormatSettingUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ScoringFormatSettingWhereUniqueInput
}

input ScoringFormatSettingUpsertNestedInput {
  update: ScoringFormatSettingUpdateDataInput!
  create: ScoringFormatSettingCreateInput!
}

input ScoringFormatSettingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  scoreRange: Int
  scoreRange_not: Int
  scoreRange_in: [Int!]
  scoreRange_not_in: [Int!]
  scoreRange_lt: Int
  scoreRange_lte: Int
  scoreRange_gt: Int
  scoreRange_gte: Int
  stars: Int
  stars_not: Int
  stars_in: [Int!]
  stars_not_in: [Int!]
  stars_lt: Int
  stars_lte: Int
  stars_gt: Int
  stars_gte: Int
  AND: [ScoringFormatSettingWhereInput!]
  OR: [ScoringFormatSettingWhereInput!]
  NOT: [ScoringFormatSettingWhereInput!]
}

input ScoringFormatSettingWhereUniqueInput {
  id: ID
}

type Sector {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

type SectorConnection {
  pageInfo: PageInfo!
  edges: [SectorEdge]!
  aggregate: AggregateSector!
}

input SectorCreateInput {
  id: ID
  name: String!
}

input SectorCreateManyInput {
  create: [SectorCreateInput!]
  connect: [SectorWhereUniqueInput!]
}

type SectorEdge {
  node: Sector!
  cursor: String!
}

enum SectorOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SectorPreviousValues {
  id: ID!
  name: String!
  createdAt: DateTime
  updatedAt: DateTime
}

input SectorScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SectorScalarWhereInput!]
  OR: [SectorScalarWhereInput!]
  NOT: [SectorScalarWhereInput!]
}

type SectorSubscriptionPayload {
  mutation: MutationType!
  node: Sector
  updatedFields: [String!]
  previousValues: SectorPreviousValues
}

input SectorSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SectorWhereInput
  AND: [SectorSubscriptionWhereInput!]
  OR: [SectorSubscriptionWhereInput!]
  NOT: [SectorSubscriptionWhereInput!]
}

input SectorUpdateDataInput {
  name: String
}

input SectorUpdateInput {
  name: String
}

input SectorUpdateManyDataInput {
  name: String
}

input SectorUpdateManyInput {
  create: [SectorCreateInput!]
  update: [SectorUpdateWithWhereUniqueNestedInput!]
  upsert: [SectorUpsertWithWhereUniqueNestedInput!]
  delete: [SectorWhereUniqueInput!]
  connect: [SectorWhereUniqueInput!]
  set: [SectorWhereUniqueInput!]
  disconnect: [SectorWhereUniqueInput!]
  deleteMany: [SectorScalarWhereInput!]
  updateMany: [SectorUpdateManyWithWhereNestedInput!]
}

input SectorUpdateManyMutationInput {
  name: String
}

input SectorUpdateManyWithWhereNestedInput {
  where: SectorScalarWhereInput!
  data: SectorUpdateManyDataInput!
}

input SectorUpdateWithWhereUniqueNestedInput {
  where: SectorWhereUniqueInput!
  data: SectorUpdateDataInput!
}

input SectorUpsertWithWhereUniqueNestedInput {
  where: SectorWhereUniqueInput!
  update: SectorUpdateDataInput!
  create: SectorCreateInput!
}

input SectorWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SectorWhereInput!]
  OR: [SectorWhereInput!]
  NOT: [SectorWhereInput!]
}

input SectorWhereUniqueInput {
  id: ID
  name: String
}

type Subscription {
  admin(where: AdminSubscriptionWhereInput): AdminSubscriptionPayload
  answer(where: AnswerSubscriptionWhereInput): AnswerSubscriptionPayload
  changePasswordRequest(where: ChangePasswordRequestSubscriptionWhereInput): ChangePasswordRequestSubscriptionPayload
  city(where: CitySubscriptionWhereInput): CitySubscriptionPayload
  country(where: CountrySubscriptionWhereInput): CountrySubscriptionPayload
  currency(where: CurrencySubscriptionWhereInput): CurrencySubscriptionPayload
  expertise(where: ExpertiseSubscriptionWhereInput): ExpertiseSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  form(where: FormSubscriptionWhereInput): FormSubscriptionPayload
  formResponse(where: FormResponseSubscriptionWhereInput): FormResponseSubscriptionPayload
  formScore(where: FormScoreSubscriptionWhereInput): FormScoreSubscriptionPayload
  invitation(where: InvitationSubscriptionWhereInput): InvitationSubscriptionPayload
  organization(where: OrganizationSubscriptionWhereInput): OrganizationSubscriptionPayload
  organizationStaff(where: OrganizationStaffSubscriptionWhereInput): OrganizationStaffSubscriptionPayload
  paymentMethod(where: PaymentMethodSubscriptionWhereInput): PaymentMethodSubscriptionPayload
  question(where: QuestionSubscriptionWhereInput): QuestionSubscriptionPayload
  score(where: ScoreSubscriptionWhereInput): ScoreSubscriptionPayload
  scoringFormatSetting(where: ScoringFormatSettingSubscriptionWhereInput): ScoringFormatSettingSubscriptionPayload
  sector(where: SectorSubscriptionWhereInput): SectorSubscriptionPayload
  systemSubscription(where: SystemSubscriptionSubscriptionWhereInput): SystemSubscriptionSubscriptionPayload
  systemSubscriptionPlan(where: SystemSubscriptionPlanSubscriptionWhereInput): SystemSubscriptionPlanSubscriptionPayload
  timezone(where: TimezoneSubscriptionWhereInput): TimezoneSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  workflow(where: WorkflowSubscriptionWhereInput): WorkflowSubscriptionPayload
  workflowApplication(where: WorkflowApplicationSubscriptionWhereInput): WorkflowApplicationSubscriptionPayload
  workflowJudge(where: WorkflowJudgeSubscriptionWhereInput): WorkflowJudgeSubscriptionPayload
  workflowSubscription(where: WorkflowSubscriptionSubscriptionWhereInput): WorkflowSubscriptionSubscriptionPayload
  workflowSubscriptionPlan(where: WorkflowSubscriptionPlanSubscriptionWhereInput): WorkflowSubscriptionPlanSubscriptionPayload
}

enum SubscriptionType {
  WORKFLOW
  ORGANIZATION
  SYSTEM
}

type SystemSubscription {
  id: ID!
  plan: SystemSubscriptionPlan!
  organization: Organization!
  paymentTrackingNumber: String
  status: ProcessState!
  createdAt: DateTime
  updatedAt: DateTime
}

type SystemSubscriptionConnection {
  pageInfo: PageInfo!
  edges: [SystemSubscriptionEdge]!
  aggregate: AggregateSystemSubscription!
}

input SystemSubscriptionCreateInput {
  id: ID
  plan: SystemSubscriptionPlanCreateOneInput!
  organization: OrganizationCreateOneInput!
  paymentTrackingNumber: String
  status: ProcessState
}

type SystemSubscriptionEdge {
  node: SystemSubscription!
  cursor: String!
}

enum SystemSubscriptionOrderByInput {
  id_ASC
  id_DESC
  paymentTrackingNumber_ASC
  paymentTrackingNumber_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SystemSubscriptionPlan {
  id: ID!
  name: String!
  description: String!
  price: Float!
  paymentMethods(where: PaymentMethodWhereInput, orderBy: PaymentMethodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentMethod!]
  currency: Currency!
  type: SubscriptionType!
  timeSpan: Int!
  createdAt: DateTime
  updatedAt: DateTime
}

type SystemSubscriptionPlanConnection {
  pageInfo: PageInfo!
  edges: [SystemSubscriptionPlanEdge]!
  aggregate: AggregateSystemSubscriptionPlan!
}

input SystemSubscriptionPlanCreateInput {
  id: ID
  name: String!
  description: String!
  price: Float
  paymentMethods: PaymentMethodCreateManyInput
  currency: CurrencyCreateOneInput!
  type: SubscriptionType
  timeSpan: Int
}

input SystemSubscriptionPlanCreateOneInput {
  create: SystemSubscriptionPlanCreateInput
  connect: SystemSubscriptionPlanWhereUniqueInput
}

type SystemSubscriptionPlanEdge {
  node: SystemSubscriptionPlan!
  cursor: String!
}

enum SystemSubscriptionPlanOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  price_ASC
  price_DESC
  type_ASC
  type_DESC
  timeSpan_ASC
  timeSpan_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SystemSubscriptionPlanPreviousValues {
  id: ID!
  name: String!
  description: String!
  price: Float!
  type: SubscriptionType!
  timeSpan: Int!
  createdAt: DateTime
  updatedAt: DateTime
}

type SystemSubscriptionPlanSubscriptionPayload {
  mutation: MutationType!
  node: SystemSubscriptionPlan
  updatedFields: [String!]
  previousValues: SystemSubscriptionPlanPreviousValues
}

input SystemSubscriptionPlanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SystemSubscriptionPlanWhereInput
  AND: [SystemSubscriptionPlanSubscriptionWhereInput!]
  OR: [SystemSubscriptionPlanSubscriptionWhereInput!]
  NOT: [SystemSubscriptionPlanSubscriptionWhereInput!]
}

input SystemSubscriptionPlanUpdateDataInput {
  name: String
  description: String
  price: Float
  paymentMethods: PaymentMethodUpdateManyInput
  currency: CurrencyUpdateOneRequiredInput
  type: SubscriptionType
  timeSpan: Int
}

input SystemSubscriptionPlanUpdateInput {
  name: String
  description: String
  price: Float
  paymentMethods: PaymentMethodUpdateManyInput
  currency: CurrencyUpdateOneRequiredInput
  type: SubscriptionType
  timeSpan: Int
}

input SystemSubscriptionPlanUpdateManyMutationInput {
  name: String
  description: String
  price: Float
  type: SubscriptionType
  timeSpan: Int
}

input SystemSubscriptionPlanUpdateOneRequiredInput {
  create: SystemSubscriptionPlanCreateInput
  update: SystemSubscriptionPlanUpdateDataInput
  upsert: SystemSubscriptionPlanUpsertNestedInput
  connect: SystemSubscriptionPlanWhereUniqueInput
}

input SystemSubscriptionPlanUpsertNestedInput {
  update: SystemSubscriptionPlanUpdateDataInput!
  create: SystemSubscriptionPlanCreateInput!
}

input SystemSubscriptionPlanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  paymentMethods_every: PaymentMethodWhereInput
  paymentMethods_some: PaymentMethodWhereInput
  paymentMethods_none: PaymentMethodWhereInput
  currency: CurrencyWhereInput
  type: SubscriptionType
  type_not: SubscriptionType
  type_in: [SubscriptionType!]
  type_not_in: [SubscriptionType!]
  timeSpan: Int
  timeSpan_not: Int
  timeSpan_in: [Int!]
  timeSpan_not_in: [Int!]
  timeSpan_lt: Int
  timeSpan_lte: Int
  timeSpan_gt: Int
  timeSpan_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SystemSubscriptionPlanWhereInput!]
  OR: [SystemSubscriptionPlanWhereInput!]
  NOT: [SystemSubscriptionPlanWhereInput!]
}

input SystemSubscriptionPlanWhereUniqueInput {
  id: ID
}

type SystemSubscriptionPreviousValues {
  id: ID!
  paymentTrackingNumber: String
  status: ProcessState!
  createdAt: DateTime
  updatedAt: DateTime
}

type SystemSubscriptionSubscriptionPayload {
  mutation: MutationType!
  node: SystemSubscription
  updatedFields: [String!]
  previousValues: SystemSubscriptionPreviousValues
}

input SystemSubscriptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SystemSubscriptionWhereInput
  AND: [SystemSubscriptionSubscriptionWhereInput!]
  OR: [SystemSubscriptionSubscriptionWhereInput!]
  NOT: [SystemSubscriptionSubscriptionWhereInput!]
}

input SystemSubscriptionUpdateInput {
  plan: SystemSubscriptionPlanUpdateOneRequiredInput
  organization: OrganizationUpdateOneRequiredInput
  paymentTrackingNumber: String
  status: ProcessState
}

input SystemSubscriptionUpdateManyMutationInput {
  paymentTrackingNumber: String
  status: ProcessState
}

input SystemSubscriptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  plan: SystemSubscriptionPlanWhereInput
  organization: OrganizationWhereInput
  paymentTrackingNumber: String
  paymentTrackingNumber_not: String
  paymentTrackingNumber_in: [String!]
  paymentTrackingNumber_not_in: [String!]
  paymentTrackingNumber_lt: String
  paymentTrackingNumber_lte: String
  paymentTrackingNumber_gt: String
  paymentTrackingNumber_gte: String
  paymentTrackingNumber_contains: String
  paymentTrackingNumber_not_contains: String
  paymentTrackingNumber_starts_with: String
  paymentTrackingNumber_not_starts_with: String
  paymentTrackingNumber_ends_with: String
  paymentTrackingNumber_not_ends_with: String
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SystemSubscriptionWhereInput!]
  OR: [SystemSubscriptionWhereInput!]
  NOT: [SystemSubscriptionWhereInput!]
}

input SystemSubscriptionWhereUniqueInput {
  id: ID
}

type Timezone {
  id: ID!
  code: String!
  description: String!
  offset: Int!
  createdAt: DateTime
  updatedAt: DateTime
}

type TimezoneConnection {
  pageInfo: PageInfo!
  edges: [TimezoneEdge]!
  aggregate: AggregateTimezone!
}

input TimezoneCreateInput {
  id: ID
  code: String!
  description: String!
  offset: Int!
}

input TimezoneCreateOneInput {
  create: TimezoneCreateInput
  connect: TimezoneWhereUniqueInput
}

type TimezoneEdge {
  node: Timezone!
  cursor: String!
}

enum TimezoneOrderByInput {
  id_ASC
  id_DESC
  code_ASC
  code_DESC
  description_ASC
  description_DESC
  offset_ASC
  offset_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TimezonePreviousValues {
  id: ID!
  code: String!
  description: String!
  offset: Int!
  createdAt: DateTime
  updatedAt: DateTime
}

type TimezoneSubscriptionPayload {
  mutation: MutationType!
  node: Timezone
  updatedFields: [String!]
  previousValues: TimezonePreviousValues
}

input TimezoneSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TimezoneWhereInput
  AND: [TimezoneSubscriptionWhereInput!]
  OR: [TimezoneSubscriptionWhereInput!]
  NOT: [TimezoneSubscriptionWhereInput!]
}

input TimezoneUpdateDataInput {
  code: String
  description: String
  offset: Int
}

input TimezoneUpdateInput {
  code: String
  description: String
  offset: Int
}

input TimezoneUpdateManyMutationInput {
  code: String
  description: String
  offset: Int
}

input TimezoneUpdateOneRequiredInput {
  create: TimezoneCreateInput
  update: TimezoneUpdateDataInput
  upsert: TimezoneUpsertNestedInput
  connect: TimezoneWhereUniqueInput
}

input TimezoneUpsertNestedInput {
  update: TimezoneUpdateDataInput!
  create: TimezoneCreateInput!
}

input TimezoneWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  code: String
  code_not: String
  code_in: [String!]
  code_not_in: [String!]
  code_lt: String
  code_lte: String
  code_gt: String
  code_gte: String
  code_contains: String
  code_not_contains: String
  code_starts_with: String
  code_not_starts_with: String
  code_ends_with: String
  code_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  offset: Int
  offset_not: Int
  offset_in: [Int!]
  offset_not_in: [Int!]
  offset_lt: Int
  offset_lte: Int
  offset_gt: Int
  offset_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [TimezoneWhereInput!]
  OR: [TimezoneWhereInput!]
  NOT: [TimezoneWhereInput!]
}

input TimezoneWhereUniqueInput {
  id: ID
  description: String
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: Country
  city: City
  bio: String
  profilePicture: File
  expertise(where: ExpertiseWhereInput, orderBy: ExpertiseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Expertise!]
  organizations(where: OrganizationWhereInput, orderBy: OrganizationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Organization!]
  registered: Boolean!
  workflowsApplied(where: WorkflowApplicationWhereInput, orderBy: WorkflowApplicationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkflowApplication!]
  createdAt: DateTime
  updatedAt: DateTime
  linkedIn: String
  invitations(where: InvitationWhereInput, orderBy: InvitationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invitation!]
  outgoingInvitations(where: InvitationWhereInput, orderBy: InvitationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Invitation!]
  staffOf(where: OrganizationStaffWhereInput, orderBy: OrganizationStaffOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [OrganizationStaff!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  password: String!
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryCreateOneInput
  city: CityCreateOneInput
  bio: String
  profilePicture: FileCreateOneInput
  expertise: ExpertiseCreateManyInput
  organizations: OrganizationCreateManyInput
  registered: Boolean!
  workflowsApplied: WorkflowApplicationCreateManyWithoutUserInput
  linkedIn: String
  invitations: InvitationCreateManyWithoutInviteeInput
  outgoingInvitations: InvitationCreateManyWithoutInviterInput
  staffOf: OrganizationStaffCreateManyWithoutUserInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutInvitationsInput {
  create: UserCreateWithoutInvitationsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOutgoingInvitationsInput {
  create: UserCreateWithoutOutgoingInvitationsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutStaffOfInput {
  create: UserCreateWithoutStaffOfInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutWorkflowsAppliedInput {
  create: UserCreateWithoutWorkflowsAppliedInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutInvitationsInput {
  id: ID
  name: String!
  email: String!
  password: String!
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryCreateOneInput
  city: CityCreateOneInput
  bio: String
  profilePicture: FileCreateOneInput
  expertise: ExpertiseCreateManyInput
  organizations: OrganizationCreateManyInput
  registered: Boolean!
  workflowsApplied: WorkflowApplicationCreateManyWithoutUserInput
  linkedIn: String
  outgoingInvitations: InvitationCreateManyWithoutInviterInput
  staffOf: OrganizationStaffCreateManyWithoutUserInput
}

input UserCreateWithoutOutgoingInvitationsInput {
  id: ID
  name: String!
  email: String!
  password: String!
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryCreateOneInput
  city: CityCreateOneInput
  bio: String
  profilePicture: FileCreateOneInput
  expertise: ExpertiseCreateManyInput
  organizations: OrganizationCreateManyInput
  registered: Boolean!
  workflowsApplied: WorkflowApplicationCreateManyWithoutUserInput
  linkedIn: String
  invitations: InvitationCreateManyWithoutInviteeInput
  staffOf: OrganizationStaffCreateManyWithoutUserInput
}

input UserCreateWithoutStaffOfInput {
  id: ID
  name: String!
  email: String!
  password: String!
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryCreateOneInput
  city: CityCreateOneInput
  bio: String
  profilePicture: FileCreateOneInput
  expertise: ExpertiseCreateManyInput
  organizations: OrganizationCreateManyInput
  registered: Boolean!
  workflowsApplied: WorkflowApplicationCreateManyWithoutUserInput
  linkedIn: String
  invitations: InvitationCreateManyWithoutInviteeInput
  outgoingInvitations: InvitationCreateManyWithoutInviterInput
}

input UserCreateWithoutWorkflowsAppliedInput {
  id: ID
  name: String!
  email: String!
  password: String!
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryCreateOneInput
  city: CityCreateOneInput
  bio: String
  profilePicture: FileCreateOneInput
  expertise: ExpertiseCreateManyInput
  organizations: OrganizationCreateManyInput
  registered: Boolean!
  linkedIn: String
  invitations: InvitationCreateManyWithoutInviteeInput
  outgoingInvitations: InvitationCreateManyWithoutInviterInput
  staffOf: OrganizationStaffCreateManyWithoutUserInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  title_ASC
  title_DESC
  phone_ASC
  phone_DESC
  dateOfBirth_ASC
  dateOfBirth_DESC
  bio_ASC
  bio_DESC
  registered_ASC
  registered_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  linkedIn_ASC
  linkedIn_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  bio: String
  registered: Boolean!
  createdAt: DateTime
  updatedAt: DateTime
  linkedIn: String
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

enum UserTitle {
  CEO
  Director
  Manager
  Staff
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryUpdateOneInput
  city: CityUpdateOneInput
  bio: String
  profilePicture: FileUpdateOneInput
  expertise: ExpertiseUpdateManyInput
  organizations: OrganizationUpdateManyInput
  registered: Boolean
  workflowsApplied: WorkflowApplicationUpdateManyWithoutUserInput
  linkedIn: String
  invitations: InvitationUpdateManyWithoutInviteeInput
  outgoingInvitations: InvitationUpdateManyWithoutInviterInput
  staffOf: OrganizationStaffUpdateManyWithoutUserInput
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryUpdateOneInput
  city: CityUpdateOneInput
  bio: String
  profilePicture: FileUpdateOneInput
  expertise: ExpertiseUpdateManyInput
  organizations: OrganizationUpdateManyInput
  registered: Boolean
  workflowsApplied: WorkflowApplicationUpdateManyWithoutUserInput
  linkedIn: String
  invitations: InvitationUpdateManyWithoutInviteeInput
  outgoingInvitations: InvitationUpdateManyWithoutInviterInput
  staffOf: OrganizationStaffUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  bio: String
  registered: Boolean
  linkedIn: String
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutInvitationsInput {
  create: UserCreateWithoutInvitationsInput
  update: UserUpdateWithoutInvitationsDataInput
  upsert: UserUpsertWithoutInvitationsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutOutgoingInvitationsInput {
  create: UserCreateWithoutOutgoingInvitationsInput
  update: UserUpdateWithoutOutgoingInvitationsDataInput
  upsert: UserUpsertWithoutOutgoingInvitationsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutStaffOfInput {
  create: UserCreateWithoutStaffOfInput
  update: UserUpdateWithoutStaffOfDataInput
  upsert: UserUpsertWithoutStaffOfInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutWorkflowsAppliedInput {
  create: UserCreateWithoutWorkflowsAppliedInput
  update: UserUpdateWithoutWorkflowsAppliedDataInput
  upsert: UserUpsertWithoutWorkflowsAppliedInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutInvitationsDataInput {
  name: String
  email: String
  password: String
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryUpdateOneInput
  city: CityUpdateOneInput
  bio: String
  profilePicture: FileUpdateOneInput
  expertise: ExpertiseUpdateManyInput
  organizations: OrganizationUpdateManyInput
  registered: Boolean
  workflowsApplied: WorkflowApplicationUpdateManyWithoutUserInput
  linkedIn: String
  outgoingInvitations: InvitationUpdateManyWithoutInviterInput
  staffOf: OrganizationStaffUpdateManyWithoutUserInput
}

input UserUpdateWithoutOutgoingInvitationsDataInput {
  name: String
  email: String
  password: String
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryUpdateOneInput
  city: CityUpdateOneInput
  bio: String
  profilePicture: FileUpdateOneInput
  expertise: ExpertiseUpdateManyInput
  organizations: OrganizationUpdateManyInput
  registered: Boolean
  workflowsApplied: WorkflowApplicationUpdateManyWithoutUserInput
  linkedIn: String
  invitations: InvitationUpdateManyWithoutInviteeInput
  staffOf: OrganizationStaffUpdateManyWithoutUserInput
}

input UserUpdateWithoutStaffOfDataInput {
  name: String
  email: String
  password: String
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryUpdateOneInput
  city: CityUpdateOneInput
  bio: String
  profilePicture: FileUpdateOneInput
  expertise: ExpertiseUpdateManyInput
  organizations: OrganizationUpdateManyInput
  registered: Boolean
  workflowsApplied: WorkflowApplicationUpdateManyWithoutUserInput
  linkedIn: String
  invitations: InvitationUpdateManyWithoutInviteeInput
  outgoingInvitations: InvitationUpdateManyWithoutInviterInput
}

input UserUpdateWithoutWorkflowsAppliedDataInput {
  name: String
  email: String
  password: String
  title: UserTitle
  phone: String
  dateOfBirth: DateTime
  country: CountryUpdateOneInput
  city: CityUpdateOneInput
  bio: String
  profilePicture: FileUpdateOneInput
  expertise: ExpertiseUpdateManyInput
  organizations: OrganizationUpdateManyInput
  registered: Boolean
  linkedIn: String
  invitations: InvitationUpdateManyWithoutInviteeInput
  outgoingInvitations: InvitationUpdateManyWithoutInviterInput
  staffOf: OrganizationStaffUpdateManyWithoutUserInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutInvitationsInput {
  update: UserUpdateWithoutInvitationsDataInput!
  create: UserCreateWithoutInvitationsInput!
}

input UserUpsertWithoutOutgoingInvitationsInput {
  update: UserUpdateWithoutOutgoingInvitationsDataInput!
  create: UserCreateWithoutOutgoingInvitationsInput!
}

input UserUpsertWithoutStaffOfInput {
  update: UserUpdateWithoutStaffOfDataInput!
  create: UserCreateWithoutStaffOfInput!
}

input UserUpsertWithoutWorkflowsAppliedInput {
  update: UserUpdateWithoutWorkflowsAppliedDataInput!
  create: UserCreateWithoutWorkflowsAppliedInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  title: UserTitle
  title_not: UserTitle
  title_in: [UserTitle!]
  title_not_in: [UserTitle!]
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  dateOfBirth: DateTime
  dateOfBirth_not: DateTime
  dateOfBirth_in: [DateTime!]
  dateOfBirth_not_in: [DateTime!]
  dateOfBirth_lt: DateTime
  dateOfBirth_lte: DateTime
  dateOfBirth_gt: DateTime
  dateOfBirth_gte: DateTime
  country: CountryWhereInput
  city: CityWhereInput
  bio: String
  bio_not: String
  bio_in: [String!]
  bio_not_in: [String!]
  bio_lt: String
  bio_lte: String
  bio_gt: String
  bio_gte: String
  bio_contains: String
  bio_not_contains: String
  bio_starts_with: String
  bio_not_starts_with: String
  bio_ends_with: String
  bio_not_ends_with: String
  profilePicture: FileWhereInput
  expertise_every: ExpertiseWhereInput
  expertise_some: ExpertiseWhereInput
  expertise_none: ExpertiseWhereInput
  organizations_every: OrganizationWhereInput
  organizations_some: OrganizationWhereInput
  organizations_none: OrganizationWhereInput
  registered: Boolean
  registered_not: Boolean
  workflowsApplied_every: WorkflowApplicationWhereInput
  workflowsApplied_some: WorkflowApplicationWhereInput
  workflowsApplied_none: WorkflowApplicationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  linkedIn: String
  linkedIn_not: String
  linkedIn_in: [String!]
  linkedIn_not_in: [String!]
  linkedIn_lt: String
  linkedIn_lte: String
  linkedIn_gt: String
  linkedIn_gte: String
  linkedIn_contains: String
  linkedIn_not_contains: String
  linkedIn_starts_with: String
  linkedIn_not_starts_with: String
  linkedIn_ends_with: String
  linkedIn_not_ends_with: String
  invitations_every: InvitationWhereInput
  invitations_some: InvitationWhereInput
  invitations_none: InvitationWhereInput
  outgoingInvitations_every: InvitationWhereInput
  outgoingInvitations_some: InvitationWhereInput
  outgoingInvitations_none: InvitationWhereInput
  staffOf_every: OrganizationStaffWhereInput
  staffOf_some: OrganizationStaffWhereInput
  staffOf_none: OrganizationStaffWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
  phone: String
}

type Workflow {
  id: ID!
  name: String!
  description: String!
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: Timezone!
  organization: Organization!
  subscriptionsPlans(where: WorkflowSubscriptionPlanWhereInput, orderBy: WorkflowSubscriptionPlanOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [WorkflowSubscriptionPlan!]
  banner: File!
  forms(where: FormWhereInput, orderBy: FormOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Form!]
  createdAt: DateTime
  updatedAt: DateTime
}

type WorkflowApplication {
  id: ID!
  user: User!
  workflow: Workflow!
  status: ProcessState!
  organization: Organization!
  createdAt: DateTime
  updatedAt: DateTime
}

type WorkflowApplicationConnection {
  pageInfo: PageInfo!
  edges: [WorkflowApplicationEdge]!
  aggregate: AggregateWorkflowApplication!
}

input WorkflowApplicationCreateInput {
  id: ID
  user: UserCreateOneWithoutWorkflowsAppliedInput!
  workflow: WorkflowCreateOneInput!
  status: ProcessState
  organization: OrganizationCreateOneInput!
}

input WorkflowApplicationCreateManyWithoutUserInput {
  create: [WorkflowApplicationCreateWithoutUserInput!]
  connect: [WorkflowApplicationWhereUniqueInput!]
}

input WorkflowApplicationCreateWithoutUserInput {
  id: ID
  workflow: WorkflowCreateOneInput!
  status: ProcessState
  organization: OrganizationCreateOneInput!
}

type WorkflowApplicationEdge {
  node: WorkflowApplication!
  cursor: String!
}

enum WorkflowApplicationOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WorkflowApplicationPreviousValues {
  id: ID!
  status: ProcessState!
  createdAt: DateTime
  updatedAt: DateTime
}

input WorkflowApplicationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowApplicationScalarWhereInput!]
  OR: [WorkflowApplicationScalarWhereInput!]
  NOT: [WorkflowApplicationScalarWhereInput!]
}

type WorkflowApplicationSubscriptionPayload {
  mutation: MutationType!
  node: WorkflowApplication
  updatedFields: [String!]
  previousValues: WorkflowApplicationPreviousValues
}

input WorkflowApplicationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkflowApplicationWhereInput
  AND: [WorkflowApplicationSubscriptionWhereInput!]
  OR: [WorkflowApplicationSubscriptionWhereInput!]
  NOT: [WorkflowApplicationSubscriptionWhereInput!]
}

input WorkflowApplicationUpdateInput {
  user: UserUpdateOneRequiredWithoutWorkflowsAppliedInput
  workflow: WorkflowUpdateOneRequiredInput
  status: ProcessState
  organization: OrganizationUpdateOneRequiredInput
}

input WorkflowApplicationUpdateManyDataInput {
  status: ProcessState
}

input WorkflowApplicationUpdateManyMutationInput {
  status: ProcessState
}

input WorkflowApplicationUpdateManyWithoutUserInput {
  create: [WorkflowApplicationCreateWithoutUserInput!]
  delete: [WorkflowApplicationWhereUniqueInput!]
  connect: [WorkflowApplicationWhereUniqueInput!]
  set: [WorkflowApplicationWhereUniqueInput!]
  disconnect: [WorkflowApplicationWhereUniqueInput!]
  update: [WorkflowApplicationUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [WorkflowApplicationUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [WorkflowApplicationScalarWhereInput!]
  updateMany: [WorkflowApplicationUpdateManyWithWhereNestedInput!]
}

input WorkflowApplicationUpdateManyWithWhereNestedInput {
  where: WorkflowApplicationScalarWhereInput!
  data: WorkflowApplicationUpdateManyDataInput!
}

input WorkflowApplicationUpdateWithoutUserDataInput {
  workflow: WorkflowUpdateOneRequiredInput
  status: ProcessState
  organization: OrganizationUpdateOneRequiredInput
}

input WorkflowApplicationUpdateWithWhereUniqueWithoutUserInput {
  where: WorkflowApplicationWhereUniqueInput!
  data: WorkflowApplicationUpdateWithoutUserDataInput!
}

input WorkflowApplicationUpsertWithWhereUniqueWithoutUserInput {
  where: WorkflowApplicationWhereUniqueInput!
  update: WorkflowApplicationUpdateWithoutUserDataInput!
  create: WorkflowApplicationCreateWithoutUserInput!
}

input WorkflowApplicationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  workflow: WorkflowWhereInput
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  organization: OrganizationWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowApplicationWhereInput!]
  OR: [WorkflowApplicationWhereInput!]
  NOT: [WorkflowApplicationWhereInput!]
}

input WorkflowApplicationWhereUniqueInput {
  id: ID
}

type WorkflowConnection {
  pageInfo: PageInfo!
  edges: [WorkflowEdge]!
  aggregate: AggregateWorkflow!
}

input WorkflowCreateInput {
  id: ID
  name: String!
  description: String!
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneCreateOneInput!
  organization: OrganizationCreateOneWithoutWorkflowsInput!
  subscriptionsPlans: WorkflowSubscriptionPlanCreateManyWithoutWorkflowInput
  banner: FileCreateOneInput!
  forms: FormCreateManyWithoutWorkflowInput
}

input WorkflowCreateManyWithoutOrganizationInput {
  create: [WorkflowCreateWithoutOrganizationInput!]
  connect: [WorkflowWhereUniqueInput!]
}

input WorkflowCreateOneInput {
  create: WorkflowCreateInput
  connect: WorkflowWhereUniqueInput
}

input WorkflowCreateOneWithoutFormsInput {
  create: WorkflowCreateWithoutFormsInput
  connect: WorkflowWhereUniqueInput
}

input WorkflowCreateOneWithoutSubscriptionsPlansInput {
  create: WorkflowCreateWithoutSubscriptionsPlansInput
  connect: WorkflowWhereUniqueInput
}

input WorkflowCreateWithoutFormsInput {
  id: ID
  name: String!
  description: String!
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneCreateOneInput!
  organization: OrganizationCreateOneWithoutWorkflowsInput!
  subscriptionsPlans: WorkflowSubscriptionPlanCreateManyWithoutWorkflowInput
  banner: FileCreateOneInput!
}

input WorkflowCreateWithoutOrganizationInput {
  id: ID
  name: String!
  description: String!
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneCreateOneInput!
  subscriptionsPlans: WorkflowSubscriptionPlanCreateManyWithoutWorkflowInput
  banner: FileCreateOneInput!
  forms: FormCreateManyWithoutWorkflowInput
}

input WorkflowCreateWithoutSubscriptionsPlansInput {
  id: ID
  name: String!
  description: String!
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneCreateOneInput!
  organization: OrganizationCreateOneWithoutWorkflowsInput!
  banner: FileCreateOneInput!
  forms: FormCreateManyWithoutWorkflowInput
}

type WorkflowEdge {
  node: Workflow!
  cursor: String!
}

type WorkflowJudge {
  id: ID!
  user: User!
  workflow: Workflow!
  status: ProcessState!
  createdAt: DateTime
  updatedAt: DateTime
}

type WorkflowJudgeConnection {
  pageInfo: PageInfo!
  edges: [WorkflowJudgeEdge]!
  aggregate: AggregateWorkflowJudge!
}

input WorkflowJudgeCreateInput {
  id: ID
  user: UserCreateOneInput!
  workflow: WorkflowCreateOneInput!
  status: ProcessState
}

input WorkflowJudgeCreateManyInput {
  create: [WorkflowJudgeCreateInput!]
  connect: [WorkflowJudgeWhereUniqueInput!]
}

type WorkflowJudgeEdge {
  node: WorkflowJudge!
  cursor: String!
}

enum WorkflowJudgeOrderByInput {
  id_ASC
  id_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WorkflowJudgePreviousValues {
  id: ID!
  status: ProcessState!
  createdAt: DateTime
  updatedAt: DateTime
}

input WorkflowJudgeScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowJudgeScalarWhereInput!]
  OR: [WorkflowJudgeScalarWhereInput!]
  NOT: [WorkflowJudgeScalarWhereInput!]
}

type WorkflowJudgeSubscriptionPayload {
  mutation: MutationType!
  node: WorkflowJudge
  updatedFields: [String!]
  previousValues: WorkflowJudgePreviousValues
}

input WorkflowJudgeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkflowJudgeWhereInput
  AND: [WorkflowJudgeSubscriptionWhereInput!]
  OR: [WorkflowJudgeSubscriptionWhereInput!]
  NOT: [WorkflowJudgeSubscriptionWhereInput!]
}

input WorkflowJudgeUpdateDataInput {
  user: UserUpdateOneRequiredInput
  workflow: WorkflowUpdateOneRequiredInput
  status: ProcessState
}

input WorkflowJudgeUpdateInput {
  user: UserUpdateOneRequiredInput
  workflow: WorkflowUpdateOneRequiredInput
  status: ProcessState
}

input WorkflowJudgeUpdateManyDataInput {
  status: ProcessState
}

input WorkflowJudgeUpdateManyInput {
  create: [WorkflowJudgeCreateInput!]
  update: [WorkflowJudgeUpdateWithWhereUniqueNestedInput!]
  upsert: [WorkflowJudgeUpsertWithWhereUniqueNestedInput!]
  delete: [WorkflowJudgeWhereUniqueInput!]
  connect: [WorkflowJudgeWhereUniqueInput!]
  set: [WorkflowJudgeWhereUniqueInput!]
  disconnect: [WorkflowJudgeWhereUniqueInput!]
  deleteMany: [WorkflowJudgeScalarWhereInput!]
  updateMany: [WorkflowJudgeUpdateManyWithWhereNestedInput!]
}

input WorkflowJudgeUpdateManyMutationInput {
  status: ProcessState
}

input WorkflowJudgeUpdateManyWithWhereNestedInput {
  where: WorkflowJudgeScalarWhereInput!
  data: WorkflowJudgeUpdateManyDataInput!
}

input WorkflowJudgeUpdateWithWhereUniqueNestedInput {
  where: WorkflowJudgeWhereUniqueInput!
  data: WorkflowJudgeUpdateDataInput!
}

input WorkflowJudgeUpsertWithWhereUniqueNestedInput {
  where: WorkflowJudgeWhereUniqueInput!
  update: WorkflowJudgeUpdateDataInput!
  create: WorkflowJudgeCreateInput!
}

input WorkflowJudgeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  workflow: WorkflowWhereInput
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowJudgeWhereInput!]
  OR: [WorkflowJudgeWhereInput!]
  NOT: [WorkflowJudgeWhereInput!]
}

input WorkflowJudgeWhereUniqueInput {
  id: ID
}

enum WorkflowOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  opening_ASC
  opening_DESC
  closing_ASC
  closing_DESC
  judgingStart_ASC
  judgingStart_DESC
  judgingEnd_ASC
  judgingEnd_DESC
  shareResults_ASC
  shareResults_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WorkflowPreviousValues {
  id: ID!
  name: String!
  description: String!
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  createdAt: DateTime
  updatedAt: DateTime
}

input WorkflowScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  opening: DateTime
  opening_not: DateTime
  opening_in: [DateTime!]
  opening_not_in: [DateTime!]
  opening_lt: DateTime
  opening_lte: DateTime
  opening_gt: DateTime
  opening_gte: DateTime
  closing: DateTime
  closing_not: DateTime
  closing_in: [DateTime!]
  closing_not_in: [DateTime!]
  closing_lt: DateTime
  closing_lte: DateTime
  closing_gt: DateTime
  closing_gte: DateTime
  judgingStart: DateTime
  judgingStart_not: DateTime
  judgingStart_in: [DateTime!]
  judgingStart_not_in: [DateTime!]
  judgingStart_lt: DateTime
  judgingStart_lte: DateTime
  judgingStart_gt: DateTime
  judgingStart_gte: DateTime
  judgingEnd: DateTime
  judgingEnd_not: DateTime
  judgingEnd_in: [DateTime!]
  judgingEnd_not_in: [DateTime!]
  judgingEnd_lt: DateTime
  judgingEnd_lte: DateTime
  judgingEnd_gt: DateTime
  judgingEnd_gte: DateTime
  shareResults: DateTime
  shareResults_not: DateTime
  shareResults_in: [DateTime!]
  shareResults_not_in: [DateTime!]
  shareResults_lt: DateTime
  shareResults_lte: DateTime
  shareResults_gt: DateTime
  shareResults_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowScalarWhereInput!]
  OR: [WorkflowScalarWhereInput!]
  NOT: [WorkflowScalarWhereInput!]
}

type WorkflowSubscription {
  id: ID!
  plan: WorkflowSubscriptionPlan!
  workflow: Workflow!
  paymentTrackingNumber: String
  status: ProcessState!
  createdAt: DateTime
  updatedAt: DateTime
}

type WorkflowSubscriptionConnection {
  pageInfo: PageInfo!
  edges: [WorkflowSubscriptionEdge]!
  aggregate: AggregateWorkflowSubscription!
}

input WorkflowSubscriptionCreateInput {
  id: ID
  plan: WorkflowSubscriptionPlanCreateOneInput!
  workflow: WorkflowCreateOneInput!
  paymentTrackingNumber: String
  status: ProcessState
}

type WorkflowSubscriptionEdge {
  node: WorkflowSubscription!
  cursor: String!
}

enum WorkflowSubscriptionOrderByInput {
  id_ASC
  id_DESC
  paymentTrackingNumber_ASC
  paymentTrackingNumber_DESC
  status_ASC
  status_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WorkflowSubscriptionPayload {
  mutation: MutationType!
  node: Workflow
  updatedFields: [String!]
  previousValues: WorkflowPreviousValues
}

type WorkflowSubscriptionPlan {
  id: ID!
  name: String!
  description: String!
  workflow: Workflow!
  price: Float!
  paymentMethods(where: PaymentMethodWhereInput, orderBy: PaymentMethodOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PaymentMethod!]
  currency: Currency!
  type: SubscriptionType!
  timeSpan: Int!
  createdAt: DateTime
  updatedAt: DateTime
}

type WorkflowSubscriptionPlanConnection {
  pageInfo: PageInfo!
  edges: [WorkflowSubscriptionPlanEdge]!
  aggregate: AggregateWorkflowSubscriptionPlan!
}

input WorkflowSubscriptionPlanCreateInput {
  id: ID
  name: String!
  description: String!
  workflow: WorkflowCreateOneWithoutSubscriptionsPlansInput!
  price: Float
  paymentMethods: PaymentMethodCreateManyInput
  currency: CurrencyCreateOneInput!
  type: SubscriptionType
  timeSpan: Int
}

input WorkflowSubscriptionPlanCreateManyWithoutWorkflowInput {
  create: [WorkflowSubscriptionPlanCreateWithoutWorkflowInput!]
  connect: [WorkflowSubscriptionPlanWhereUniqueInput!]
}

input WorkflowSubscriptionPlanCreateOneInput {
  create: WorkflowSubscriptionPlanCreateInput
  connect: WorkflowSubscriptionPlanWhereUniqueInput
}

input WorkflowSubscriptionPlanCreateWithoutWorkflowInput {
  id: ID
  name: String!
  description: String!
  price: Float
  paymentMethods: PaymentMethodCreateManyInput
  currency: CurrencyCreateOneInput!
  type: SubscriptionType
  timeSpan: Int
}

type WorkflowSubscriptionPlanEdge {
  node: WorkflowSubscriptionPlan!
  cursor: String!
}

enum WorkflowSubscriptionPlanOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  price_ASC
  price_DESC
  type_ASC
  type_DESC
  timeSpan_ASC
  timeSpan_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type WorkflowSubscriptionPlanPreviousValues {
  id: ID!
  name: String!
  description: String!
  price: Float!
  type: SubscriptionType!
  timeSpan: Int!
  createdAt: DateTime
  updatedAt: DateTime
}

input WorkflowSubscriptionPlanScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  type: SubscriptionType
  type_not: SubscriptionType
  type_in: [SubscriptionType!]
  type_not_in: [SubscriptionType!]
  timeSpan: Int
  timeSpan_not: Int
  timeSpan_in: [Int!]
  timeSpan_not_in: [Int!]
  timeSpan_lt: Int
  timeSpan_lte: Int
  timeSpan_gt: Int
  timeSpan_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowSubscriptionPlanScalarWhereInput!]
  OR: [WorkflowSubscriptionPlanScalarWhereInput!]
  NOT: [WorkflowSubscriptionPlanScalarWhereInput!]
}

type WorkflowSubscriptionPlanSubscriptionPayload {
  mutation: MutationType!
  node: WorkflowSubscriptionPlan
  updatedFields: [String!]
  previousValues: WorkflowSubscriptionPlanPreviousValues
}

input WorkflowSubscriptionPlanSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkflowSubscriptionPlanWhereInput
  AND: [WorkflowSubscriptionPlanSubscriptionWhereInput!]
  OR: [WorkflowSubscriptionPlanSubscriptionWhereInput!]
  NOT: [WorkflowSubscriptionPlanSubscriptionWhereInput!]
}

input WorkflowSubscriptionPlanUpdateDataInput {
  name: String
  description: String
  workflow: WorkflowUpdateOneRequiredWithoutSubscriptionsPlansInput
  price: Float
  paymentMethods: PaymentMethodUpdateManyInput
  currency: CurrencyUpdateOneRequiredInput
  type: SubscriptionType
  timeSpan: Int
}

input WorkflowSubscriptionPlanUpdateInput {
  name: String
  description: String
  workflow: WorkflowUpdateOneRequiredWithoutSubscriptionsPlansInput
  price: Float
  paymentMethods: PaymentMethodUpdateManyInput
  currency: CurrencyUpdateOneRequiredInput
  type: SubscriptionType
  timeSpan: Int
}

input WorkflowSubscriptionPlanUpdateManyDataInput {
  name: String
  description: String
  price: Float
  type: SubscriptionType
  timeSpan: Int
}

input WorkflowSubscriptionPlanUpdateManyMutationInput {
  name: String
  description: String
  price: Float
  type: SubscriptionType
  timeSpan: Int
}

input WorkflowSubscriptionPlanUpdateManyWithoutWorkflowInput {
  create: [WorkflowSubscriptionPlanCreateWithoutWorkflowInput!]
  delete: [WorkflowSubscriptionPlanWhereUniqueInput!]
  connect: [WorkflowSubscriptionPlanWhereUniqueInput!]
  set: [WorkflowSubscriptionPlanWhereUniqueInput!]
  disconnect: [WorkflowSubscriptionPlanWhereUniqueInput!]
  update: [WorkflowSubscriptionPlanUpdateWithWhereUniqueWithoutWorkflowInput!]
  upsert: [WorkflowSubscriptionPlanUpsertWithWhereUniqueWithoutWorkflowInput!]
  deleteMany: [WorkflowSubscriptionPlanScalarWhereInput!]
  updateMany: [WorkflowSubscriptionPlanUpdateManyWithWhereNestedInput!]
}

input WorkflowSubscriptionPlanUpdateManyWithWhereNestedInput {
  where: WorkflowSubscriptionPlanScalarWhereInput!
  data: WorkflowSubscriptionPlanUpdateManyDataInput!
}

input WorkflowSubscriptionPlanUpdateOneRequiredInput {
  create: WorkflowSubscriptionPlanCreateInput
  update: WorkflowSubscriptionPlanUpdateDataInput
  upsert: WorkflowSubscriptionPlanUpsertNestedInput
  connect: WorkflowSubscriptionPlanWhereUniqueInput
}

input WorkflowSubscriptionPlanUpdateWithoutWorkflowDataInput {
  name: String
  description: String
  price: Float
  paymentMethods: PaymentMethodUpdateManyInput
  currency: CurrencyUpdateOneRequiredInput
  type: SubscriptionType
  timeSpan: Int
}

input WorkflowSubscriptionPlanUpdateWithWhereUniqueWithoutWorkflowInput {
  where: WorkflowSubscriptionPlanWhereUniqueInput!
  data: WorkflowSubscriptionPlanUpdateWithoutWorkflowDataInput!
}

input WorkflowSubscriptionPlanUpsertNestedInput {
  update: WorkflowSubscriptionPlanUpdateDataInput!
  create: WorkflowSubscriptionPlanCreateInput!
}

input WorkflowSubscriptionPlanUpsertWithWhereUniqueWithoutWorkflowInput {
  where: WorkflowSubscriptionPlanWhereUniqueInput!
  update: WorkflowSubscriptionPlanUpdateWithoutWorkflowDataInput!
  create: WorkflowSubscriptionPlanCreateWithoutWorkflowInput!
}

input WorkflowSubscriptionPlanWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  workflow: WorkflowWhereInput
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  paymentMethods_every: PaymentMethodWhereInput
  paymentMethods_some: PaymentMethodWhereInput
  paymentMethods_none: PaymentMethodWhereInput
  currency: CurrencyWhereInput
  type: SubscriptionType
  type_not: SubscriptionType
  type_in: [SubscriptionType!]
  type_not_in: [SubscriptionType!]
  timeSpan: Int
  timeSpan_not: Int
  timeSpan_in: [Int!]
  timeSpan_not_in: [Int!]
  timeSpan_lt: Int
  timeSpan_lte: Int
  timeSpan_gt: Int
  timeSpan_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowSubscriptionPlanWhereInput!]
  OR: [WorkflowSubscriptionPlanWhereInput!]
  NOT: [WorkflowSubscriptionPlanWhereInput!]
}

input WorkflowSubscriptionPlanWhereUniqueInput {
  id: ID
}

type WorkflowSubscriptionPreviousValues {
  id: ID!
  paymentTrackingNumber: String
  status: ProcessState!
  createdAt: DateTime
  updatedAt: DateTime
}

type WorkflowSubscriptionSubscriptionPayload {
  mutation: MutationType!
  node: WorkflowSubscription
  updatedFields: [String!]
  previousValues: WorkflowSubscriptionPreviousValues
}

input WorkflowSubscriptionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: WorkflowSubscriptionWhereInput
  AND: [WorkflowSubscriptionSubscriptionWhereInput!]
  OR: [WorkflowSubscriptionSubscriptionWhereInput!]
  NOT: [WorkflowSubscriptionSubscriptionWhereInput!]
}

input WorkflowSubscriptionUpdateInput {
  plan: WorkflowSubscriptionPlanUpdateOneRequiredInput
  workflow: WorkflowUpdateOneRequiredInput
  paymentTrackingNumber: String
  status: ProcessState
}

input WorkflowSubscriptionUpdateManyMutationInput {
  paymentTrackingNumber: String
  status: ProcessState
}

input WorkflowSubscriptionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  plan: WorkflowSubscriptionPlanWhereInput
  workflow: WorkflowWhereInput
  paymentTrackingNumber: String
  paymentTrackingNumber_not: String
  paymentTrackingNumber_in: [String!]
  paymentTrackingNumber_not_in: [String!]
  paymentTrackingNumber_lt: String
  paymentTrackingNumber_lte: String
  paymentTrackingNumber_gt: String
  paymentTrackingNumber_gte: String
  paymentTrackingNumber_contains: String
  paymentTrackingNumber_not_contains: String
  paymentTrackingNumber_starts_with: String
  paymentTrackingNumber_not_starts_with: String
  paymentTrackingNumber_ends_with: String
  paymentTrackingNumber_not_ends_with: String
  status: ProcessState
  status_not: ProcessState
  status_in: [ProcessState!]
  status_not_in: [ProcessState!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowSubscriptionWhereInput!]
  OR: [WorkflowSubscriptionWhereInput!]
  NOT: [WorkflowSubscriptionWhereInput!]
}

input WorkflowSubscriptionWhereUniqueInput {
  id: ID
}

input WorkflowUpdateDataInput {
  name: String
  description: String
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneUpdateOneRequiredInput
  organization: OrganizationUpdateOneRequiredWithoutWorkflowsInput
  subscriptionsPlans: WorkflowSubscriptionPlanUpdateManyWithoutWorkflowInput
  banner: FileUpdateOneRequiredInput
  forms: FormUpdateManyWithoutWorkflowInput
}

input WorkflowUpdateInput {
  name: String
  description: String
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneUpdateOneRequiredInput
  organization: OrganizationUpdateOneRequiredWithoutWorkflowsInput
  subscriptionsPlans: WorkflowSubscriptionPlanUpdateManyWithoutWorkflowInput
  banner: FileUpdateOneRequiredInput
  forms: FormUpdateManyWithoutWorkflowInput
}

input WorkflowUpdateManyDataInput {
  name: String
  description: String
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
}

input WorkflowUpdateManyMutationInput {
  name: String
  description: String
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
}

input WorkflowUpdateManyWithoutOrganizationInput {
  create: [WorkflowCreateWithoutOrganizationInput!]
  delete: [WorkflowWhereUniqueInput!]
  connect: [WorkflowWhereUniqueInput!]
  set: [WorkflowWhereUniqueInput!]
  disconnect: [WorkflowWhereUniqueInput!]
  update: [WorkflowUpdateWithWhereUniqueWithoutOrganizationInput!]
  upsert: [WorkflowUpsertWithWhereUniqueWithoutOrganizationInput!]
  deleteMany: [WorkflowScalarWhereInput!]
  updateMany: [WorkflowUpdateManyWithWhereNestedInput!]
}

input WorkflowUpdateManyWithWhereNestedInput {
  where: WorkflowScalarWhereInput!
  data: WorkflowUpdateManyDataInput!
}

input WorkflowUpdateOneRequiredInput {
  create: WorkflowCreateInput
  update: WorkflowUpdateDataInput
  upsert: WorkflowUpsertNestedInput
  connect: WorkflowWhereUniqueInput
}

input WorkflowUpdateOneRequiredWithoutFormsInput {
  create: WorkflowCreateWithoutFormsInput
  update: WorkflowUpdateWithoutFormsDataInput
  upsert: WorkflowUpsertWithoutFormsInput
  connect: WorkflowWhereUniqueInput
}

input WorkflowUpdateOneRequiredWithoutSubscriptionsPlansInput {
  create: WorkflowCreateWithoutSubscriptionsPlansInput
  update: WorkflowUpdateWithoutSubscriptionsPlansDataInput
  upsert: WorkflowUpsertWithoutSubscriptionsPlansInput
  connect: WorkflowWhereUniqueInput
}

input WorkflowUpdateWithoutFormsDataInput {
  name: String
  description: String
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneUpdateOneRequiredInput
  organization: OrganizationUpdateOneRequiredWithoutWorkflowsInput
  subscriptionsPlans: WorkflowSubscriptionPlanUpdateManyWithoutWorkflowInput
  banner: FileUpdateOneRequiredInput
}

input WorkflowUpdateWithoutOrganizationDataInput {
  name: String
  description: String
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneUpdateOneRequiredInput
  subscriptionsPlans: WorkflowSubscriptionPlanUpdateManyWithoutWorkflowInput
  banner: FileUpdateOneRequiredInput
  forms: FormUpdateManyWithoutWorkflowInput
}

input WorkflowUpdateWithoutSubscriptionsPlansDataInput {
  name: String
  description: String
  opening: DateTime
  closing: DateTime
  judgingStart: DateTime
  judgingEnd: DateTime
  shareResults: DateTime
  timezone: TimezoneUpdateOneRequiredInput
  organization: OrganizationUpdateOneRequiredWithoutWorkflowsInput
  banner: FileUpdateOneRequiredInput
  forms: FormUpdateManyWithoutWorkflowInput
}

input WorkflowUpdateWithWhereUniqueWithoutOrganizationInput {
  where: WorkflowWhereUniqueInput!
  data: WorkflowUpdateWithoutOrganizationDataInput!
}

input WorkflowUpsertNestedInput {
  update: WorkflowUpdateDataInput!
  create: WorkflowCreateInput!
}

input WorkflowUpsertWithoutFormsInput {
  update: WorkflowUpdateWithoutFormsDataInput!
  create: WorkflowCreateWithoutFormsInput!
}

input WorkflowUpsertWithoutSubscriptionsPlansInput {
  update: WorkflowUpdateWithoutSubscriptionsPlansDataInput!
  create: WorkflowCreateWithoutSubscriptionsPlansInput!
}

input WorkflowUpsertWithWhereUniqueWithoutOrganizationInput {
  where: WorkflowWhereUniqueInput!
  update: WorkflowUpdateWithoutOrganizationDataInput!
  create: WorkflowCreateWithoutOrganizationInput!
}

input WorkflowWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  opening: DateTime
  opening_not: DateTime
  opening_in: [DateTime!]
  opening_not_in: [DateTime!]
  opening_lt: DateTime
  opening_lte: DateTime
  opening_gt: DateTime
  opening_gte: DateTime
  closing: DateTime
  closing_not: DateTime
  closing_in: [DateTime!]
  closing_not_in: [DateTime!]
  closing_lt: DateTime
  closing_lte: DateTime
  closing_gt: DateTime
  closing_gte: DateTime
  judgingStart: DateTime
  judgingStart_not: DateTime
  judgingStart_in: [DateTime!]
  judgingStart_not_in: [DateTime!]
  judgingStart_lt: DateTime
  judgingStart_lte: DateTime
  judgingStart_gt: DateTime
  judgingStart_gte: DateTime
  judgingEnd: DateTime
  judgingEnd_not: DateTime
  judgingEnd_in: [DateTime!]
  judgingEnd_not_in: [DateTime!]
  judgingEnd_lt: DateTime
  judgingEnd_lte: DateTime
  judgingEnd_gt: DateTime
  judgingEnd_gte: DateTime
  shareResults: DateTime
  shareResults_not: DateTime
  shareResults_in: [DateTime!]
  shareResults_not_in: [DateTime!]
  shareResults_lt: DateTime
  shareResults_lte: DateTime
  shareResults_gt: DateTime
  shareResults_gte: DateTime
  timezone: TimezoneWhereInput
  organization: OrganizationWhereInput
  subscriptionsPlans_every: WorkflowSubscriptionPlanWhereInput
  subscriptionsPlans_some: WorkflowSubscriptionPlanWhereInput
  subscriptionsPlans_none: WorkflowSubscriptionPlanWhereInput
  banner: FileWhereInput
  forms_every: FormWhereInput
  forms_some: FormWhereInput
  forms_none: FormWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [WorkflowWhereInput!]
  OR: [WorkflowWhereInput!]
  NOT: [WorkflowWhereInput!]
}

input WorkflowWhereUniqueInput {
  id: ID
}
